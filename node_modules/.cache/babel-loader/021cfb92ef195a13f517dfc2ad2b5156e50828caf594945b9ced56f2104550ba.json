{"ast":null,"code":"// Copyright 2017 Joyent, Inc.\n\nmodule.exports = {\n  read: read,\n  verify: verify,\n  sign: sign,\n  signAsync: signAsync,\n  write: write\n};\nvar assert = require('assert-plus');\nvar asn1 = require('asn1');\nvar Buffer = require('safer-buffer').Buffer;\nvar algs = require('../algs');\nvar utils = require('../utils');\nvar Key = require('../key');\nvar PrivateKey = require('../private-key');\nvar pem = require('./pem');\nvar Identity = require('../identity');\nvar Signature = require('../signature');\nvar Certificate = require('../certificate');\nvar pkcs8 = require('./pkcs8');\n\n/*\n * This file is based on RFC5280 (X.509).\n */\n\n/* Helper to read in a single mpint */\nfunction readMPInt(der, nm) {\n  assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + ' is not an Integer');\n  return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));\n}\nfunction verify(cert, key) {\n  var sig = cert.signatures.x509;\n  assert.object(sig, 'x509 signature');\n  var algParts = sig.algo.split('-');\n  if (algParts[0] !== key.type) return false;\n  var blob = sig.cache;\n  if (blob === undefined) {\n    var der = new asn1.BerWriter();\n    writeTBSCert(cert, der);\n    blob = der.buffer;\n  }\n  var verifier = key.createVerify(algParts[1]);\n  verifier.write(blob);\n  return verifier.verify(sig.signature);\n}\nfunction Local(i) {\n  return asn1.Ber.Context | asn1.Ber.Constructor | i;\n}\nfunction Context(i) {\n  return asn1.Ber.Context | i;\n}\nvar SIGN_ALGS = {\n  'rsa-md5': '1.2.840.113549.1.1.4',\n  'rsa-sha1': '1.2.840.113549.1.1.5',\n  'rsa-sha256': '1.2.840.113549.1.1.11',\n  'rsa-sha384': '1.2.840.113549.1.1.12',\n  'rsa-sha512': '1.2.840.113549.1.1.13',\n  'dsa-sha1': '1.2.840.10040.4.3',\n  'dsa-sha256': '2.16.840.1.101.3.4.3.2',\n  'ecdsa-sha1': '1.2.840.10045.4.1',\n  'ecdsa-sha256': '1.2.840.10045.4.3.2',\n  'ecdsa-sha384': '1.2.840.10045.4.3.3',\n  'ecdsa-sha512': '1.2.840.10045.4.3.4',\n  'ed25519-sha512': '1.3.101.112'\n};\nObject.keys(SIGN_ALGS).forEach(function (k) {\n  SIGN_ALGS[SIGN_ALGS[k]] = k;\n});\nSIGN_ALGS['1.3.14.3.2.3'] = 'rsa-md5';\nSIGN_ALGS['1.3.14.3.2.29'] = 'rsa-sha1';\nvar EXTS = {\n  'issuerKeyId': '2.5.29.35',\n  'altName': '2.5.29.17',\n  'basicConstraints': '2.5.29.19',\n  'keyUsage': '2.5.29.15',\n  'extKeyUsage': '2.5.29.37'\n};\nfunction read(buf, options) {\n  if (typeof buf === 'string') {\n    buf = Buffer.from(buf, 'binary');\n  }\n  assert.buffer(buf, 'buf');\n  var der = new asn1.BerReader(buf);\n  der.readSequence();\n  if (Math.abs(der.length - der.remain) > 1) {\n    throw new Error('DER sequence does not contain whole byte ' + 'stream');\n  }\n  var tbsStart = der.offset;\n  der.readSequence();\n  var sigOffset = der.offset + der.length;\n  var tbsEnd = sigOffset;\n  if (der.peek() === Local(0)) {\n    der.readSequence(Local(0));\n    var version = der.readInt();\n    assert.ok(version <= 3, 'only x.509 versions up to v3 supported');\n  }\n  var cert = {};\n  cert.signatures = {};\n  var sig = cert.signatures.x509 = {};\n  sig.extras = {};\n  cert.serial = readMPInt(der, 'serial');\n  der.readSequence();\n  var after = der.offset + der.length;\n  var certAlgOid = der.readOID();\n  var certAlg = SIGN_ALGS[certAlgOid];\n  if (certAlg === undefined) throw new Error('unknown signature algorithm ' + certAlgOid);\n  der._offset = after;\n  cert.issuer = Identity.parseAsn1(der);\n  der.readSequence();\n  cert.validFrom = readDate(der);\n  cert.validUntil = readDate(der);\n  cert.subjects = [Identity.parseAsn1(der)];\n  der.readSequence();\n  after = der.offset + der.length;\n  cert.subjectKey = pkcs8.readPkcs8(undefined, 'public', der);\n  der._offset = after;\n\n  /* issuerUniqueID */\n  if (der.peek() === Local(1)) {\n    der.readSequence(Local(1));\n    sig.extras.issuerUniqueID = buf.slice(der.offset, der.offset + der.length);\n    der._offset += der.length;\n  }\n\n  /* subjectUniqueID */\n  if (der.peek() === Local(2)) {\n    der.readSequence(Local(2));\n    sig.extras.subjectUniqueID = buf.slice(der.offset, der.offset + der.length);\n    der._offset += der.length;\n  }\n\n  /* extensions */\n  if (der.peek() === Local(3)) {\n    der.readSequence(Local(3));\n    var extEnd = der.offset + der.length;\n    der.readSequence();\n    while (der.offset < extEnd) readExtension(cert, buf, der);\n    assert.strictEqual(der.offset, extEnd);\n  }\n  assert.strictEqual(der.offset, sigOffset);\n  der.readSequence();\n  after = der.offset + der.length;\n  var sigAlgOid = der.readOID();\n  var sigAlg = SIGN_ALGS[sigAlgOid];\n  if (sigAlg === undefined) throw new Error('unknown signature algorithm ' + sigAlgOid);\n  der._offset = after;\n  var sigData = der.readString(asn1.Ber.BitString, true);\n  if (sigData[0] === 0) sigData = sigData.slice(1);\n  var algParts = sigAlg.split('-');\n  sig.signature = Signature.parse(sigData, algParts[0], 'asn1');\n  sig.signature.hashAlgorithm = algParts[1];\n  sig.algo = sigAlg;\n  sig.cache = buf.slice(tbsStart, tbsEnd);\n  return new Certificate(cert);\n}\nfunction readDate(der) {\n  if (der.peek() === asn1.Ber.UTCTime) {\n    return utcTimeToDate(der.readString(asn1.Ber.UTCTime));\n  } else if (der.peek() === asn1.Ber.GeneralizedTime) {\n    return gTimeToDate(der.readString(asn1.Ber.GeneralizedTime));\n  } else {\n    throw new Error('Unsupported date format');\n  }\n}\nfunction writeDate(der, date) {\n  if (date.getUTCFullYear() >= 2050 || date.getUTCFullYear() < 1950) {\n    der.writeString(dateToGTime(date), asn1.Ber.GeneralizedTime);\n  } else {\n    der.writeString(dateToUTCTime(date), asn1.Ber.UTCTime);\n  }\n}\n\n/* RFC5280, section 4.2.1.6 (GeneralName type) */\nvar ALTNAME = {\n  OtherName: Local(0),\n  RFC822Name: Context(1),\n  DNSName: Context(2),\n  X400Address: Local(3),\n  DirectoryName: Local(4),\n  EDIPartyName: Local(5),\n  URI: Context(6),\n  IPAddress: Context(7),\n  OID: Context(8)\n};\n\n/* RFC5280, section 4.2.1.12 (KeyPurposeId) */\nvar EXTPURPOSE = {\n  'serverAuth': '1.3.6.1.5.5.7.3.1',\n  'clientAuth': '1.3.6.1.5.5.7.3.2',\n  'codeSigning': '1.3.6.1.5.5.7.3.3',\n  /* See https://github.com/joyent/oid-docs/blob/master/root.md */\n  'joyentDocker': '1.3.6.1.4.1.38678.1.4.1',\n  'joyentCmon': '1.3.6.1.4.1.38678.1.4.2'\n};\nvar EXTPURPOSE_REV = {};\nObject.keys(EXTPURPOSE).forEach(function (k) {\n  EXTPURPOSE_REV[EXTPURPOSE[k]] = k;\n});\nvar KEYUSEBITS = ['signature', 'identity', 'keyEncryption', 'encryption', 'keyAgreement', 'ca', 'crl'];\nfunction readExtension(cert, buf, der) {\n  der.readSequence();\n  var after = der.offset + der.length;\n  var extId = der.readOID();\n  var id;\n  var sig = cert.signatures.x509;\n  if (!sig.extras.exts) sig.extras.exts = [];\n  var critical;\n  if (der.peek() === asn1.Ber.Boolean) critical = der.readBoolean();\n  switch (extId) {\n    case EXTS.basicConstraints:\n      der.readSequence(asn1.Ber.OctetString);\n      der.readSequence();\n      var bcEnd = der.offset + der.length;\n      var ca = false;\n      if (der.peek() === asn1.Ber.Boolean) ca = der.readBoolean();\n      if (cert.purposes === undefined) cert.purposes = [];\n      if (ca === true) cert.purposes.push('ca');\n      var bc = {\n        oid: extId,\n        critical: critical\n      };\n      if (der.offset < bcEnd && der.peek() === asn1.Ber.Integer) bc.pathLen = der.readInt();\n      sig.extras.exts.push(bc);\n      break;\n    case EXTS.extKeyUsage:\n      der.readSequence(asn1.Ber.OctetString);\n      der.readSequence();\n      if (cert.purposes === undefined) cert.purposes = [];\n      var ekEnd = der.offset + der.length;\n      while (der.offset < ekEnd) {\n        var oid = der.readOID();\n        cert.purposes.push(EXTPURPOSE_REV[oid] || oid);\n      }\n      /*\n       * This is a bit of a hack: in the case where we have a cert\n       * that's only allowed to do serverAuth or clientAuth (and not\n       * the other), we want to make sure all our Subjects are of\n       * the right type. But we already parsed our Subjects and\n       * decided if they were hosts or users earlier (since it appears\n       * first in the cert).\n       *\n       * So we go through and mutate them into the right kind here if\n       * it doesn't match. This might not be hugely beneficial, as it\n       * seems that single-purpose certs are not often seen in the\n       * wild.\n       */\n      if (cert.purposes.indexOf('serverAuth') !== -1 && cert.purposes.indexOf('clientAuth') === -1) {\n        cert.subjects.forEach(function (ide) {\n          if (ide.type !== 'host') {\n            ide.type = 'host';\n            ide.hostname = ide.uid || ide.email || ide.components[0].value;\n          }\n        });\n      } else if (cert.purposes.indexOf('clientAuth') !== -1 && cert.purposes.indexOf('serverAuth') === -1) {\n        cert.subjects.forEach(function (ide) {\n          if (ide.type !== 'user') {\n            ide.type = 'user';\n            ide.uid = ide.hostname || ide.email || ide.components[0].value;\n          }\n        });\n      }\n      sig.extras.exts.push({\n        oid: extId,\n        critical: critical\n      });\n      break;\n    case EXTS.keyUsage:\n      der.readSequence(asn1.Ber.OctetString);\n      var bits = der.readString(asn1.Ber.BitString, true);\n      var setBits = readBitField(bits, KEYUSEBITS);\n      setBits.forEach(function (bit) {\n        if (cert.purposes === undefined) cert.purposes = [];\n        if (cert.purposes.indexOf(bit) === -1) cert.purposes.push(bit);\n      });\n      sig.extras.exts.push({\n        oid: extId,\n        critical: critical,\n        bits: bits\n      });\n      break;\n    case EXTS.altName:\n      der.readSequence(asn1.Ber.OctetString);\n      der.readSequence();\n      var aeEnd = der.offset + der.length;\n      while (der.offset < aeEnd) {\n        switch (der.peek()) {\n          case ALTNAME.OtherName:\n          case ALTNAME.EDIPartyName:\n            der.readSequence();\n            der._offset += der.length;\n            break;\n          case ALTNAME.OID:\n            der.readOID(ALTNAME.OID);\n            break;\n          case ALTNAME.RFC822Name:\n            /* RFC822 specifies email addresses */\n            var email = der.readString(ALTNAME.RFC822Name);\n            id = Identity.forEmail(email);\n            if (!cert.subjects[0].equals(id)) cert.subjects.push(id);\n            break;\n          case ALTNAME.DirectoryName:\n            der.readSequence(ALTNAME.DirectoryName);\n            id = Identity.parseAsn1(der);\n            if (!cert.subjects[0].equals(id)) cert.subjects.push(id);\n            break;\n          case ALTNAME.DNSName:\n            var host = der.readString(ALTNAME.DNSName);\n            id = Identity.forHost(host);\n            if (!cert.subjects[0].equals(id)) cert.subjects.push(id);\n            break;\n          default:\n            der.readString(der.peek());\n            break;\n        }\n      }\n      sig.extras.exts.push({\n        oid: extId,\n        critical: critical\n      });\n      break;\n    default:\n      sig.extras.exts.push({\n        oid: extId,\n        critical: critical,\n        data: der.readString(asn1.Ber.OctetString, true)\n      });\n      break;\n  }\n  der._offset = after;\n}\nvar UTCTIME_RE = /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;\nfunction utcTimeToDate(t) {\n  var m = t.match(UTCTIME_RE);\n  assert.ok(m, 'timestamps must be in UTC');\n  var d = new Date();\n  var thisYear = d.getUTCFullYear();\n  var century = Math.floor(thisYear / 100) * 100;\n  var year = parseInt(m[1], 10);\n  if (thisYear % 100 < 50 && year >= 60) year += century - 1;else year += century;\n  d.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));\n  d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));\n  if (m[6] && m[6].length > 0) d.setUTCSeconds(parseInt(m[6], 10));\n  return d;\n}\nvar GTIME_RE = /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;\nfunction gTimeToDate(t) {\n  var m = t.match(GTIME_RE);\n  assert.ok(m);\n  var d = new Date();\n  d.setUTCFullYear(parseInt(m[1], 10), parseInt(m[2], 10) - 1, parseInt(m[3], 10));\n  d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));\n  if (m[6] && m[6].length > 0) d.setUTCSeconds(parseInt(m[6], 10));\n  return d;\n}\nfunction zeroPad(n, m) {\n  if (m === undefined) m = 2;\n  var s = '' + n;\n  while (s.length < m) s = '0' + s;\n  return s;\n}\nfunction dateToUTCTime(d) {\n  var s = '';\n  s += zeroPad(d.getUTCFullYear() % 100);\n  s += zeroPad(d.getUTCMonth() + 1);\n  s += zeroPad(d.getUTCDate());\n  s += zeroPad(d.getUTCHours());\n  s += zeroPad(d.getUTCMinutes());\n  s += zeroPad(d.getUTCSeconds());\n  s += 'Z';\n  return s;\n}\nfunction dateToGTime(d) {\n  var s = '';\n  s += zeroPad(d.getUTCFullYear(), 4);\n  s += zeroPad(d.getUTCMonth() + 1);\n  s += zeroPad(d.getUTCDate());\n  s += zeroPad(d.getUTCHours());\n  s += zeroPad(d.getUTCMinutes());\n  s += zeroPad(d.getUTCSeconds());\n  s += 'Z';\n  return s;\n}\nfunction sign(cert, key) {\n  if (cert.signatures.x509 === undefined) cert.signatures.x509 = {};\n  var sig = cert.signatures.x509;\n  sig.algo = key.type + '-' + key.defaultHashAlgorithm();\n  if (SIGN_ALGS[sig.algo] === undefined) return false;\n  var der = new asn1.BerWriter();\n  writeTBSCert(cert, der);\n  var blob = der.buffer;\n  sig.cache = blob;\n  var signer = key.createSign();\n  signer.write(blob);\n  cert.signatures.x509.signature = signer.sign();\n  return true;\n}\nfunction signAsync(cert, signer, done) {\n  if (cert.signatures.x509 === undefined) cert.signatures.x509 = {};\n  var sig = cert.signatures.x509;\n  var der = new asn1.BerWriter();\n  writeTBSCert(cert, der);\n  var blob = der.buffer;\n  sig.cache = blob;\n  signer(blob, function (err, signature) {\n    if (err) {\n      done(err);\n      return;\n    }\n    sig.algo = signature.type + '-' + signature.hashAlgorithm;\n    if (SIGN_ALGS[sig.algo] === undefined) {\n      done(new Error('Invalid signing algorithm \"' + sig.algo + '\"'));\n      return;\n    }\n    sig.signature = signature;\n    done();\n  });\n}\nfunction write(cert, options) {\n  var sig = cert.signatures.x509;\n  assert.object(sig, 'x509 signature');\n  var der = new asn1.BerWriter();\n  der.startSequence();\n  if (sig.cache) {\n    der._ensure(sig.cache.length);\n    sig.cache.copy(der._buf, der._offset);\n    der._offset += sig.cache.length;\n  } else {\n    writeTBSCert(cert, der);\n  }\n  der.startSequence();\n  der.writeOID(SIGN_ALGS[sig.algo]);\n  if (sig.algo.match(/^rsa-/)) der.writeNull();\n  der.endSequence();\n  var sigData = sig.signature.toBuffer('asn1');\n  var data = Buffer.alloc(sigData.length + 1);\n  data[0] = 0;\n  sigData.copy(data, 1);\n  der.writeBuffer(data, asn1.Ber.BitString);\n  der.endSequence();\n  return der.buffer;\n}\nfunction writeTBSCert(cert, der) {\n  var sig = cert.signatures.x509;\n  assert.object(sig, 'x509 signature');\n  der.startSequence();\n  der.startSequence(Local(0));\n  der.writeInt(2);\n  der.endSequence();\n  der.writeBuffer(utils.mpNormalize(cert.serial), asn1.Ber.Integer);\n  der.startSequence();\n  der.writeOID(SIGN_ALGS[sig.algo]);\n  if (sig.algo.match(/^rsa-/)) der.writeNull();\n  der.endSequence();\n  cert.issuer.toAsn1(der);\n  der.startSequence();\n  writeDate(der, cert.validFrom);\n  writeDate(der, cert.validUntil);\n  der.endSequence();\n  var subject = cert.subjects[0];\n  var altNames = cert.subjects.slice(1);\n  subject.toAsn1(der);\n  pkcs8.writePkcs8(der, cert.subjectKey);\n  if (sig.extras && sig.extras.issuerUniqueID) {\n    der.writeBuffer(sig.extras.issuerUniqueID, Local(1));\n  }\n  if (sig.extras && sig.extras.subjectUniqueID) {\n    der.writeBuffer(sig.extras.subjectUniqueID, Local(2));\n  }\n  if (altNames.length > 0 || subject.type === 'host' || cert.purposes !== undefined && cert.purposes.length > 0 || sig.extras && sig.extras.exts) {\n    der.startSequence(Local(3));\n    der.startSequence();\n    var exts = [];\n    if (cert.purposes !== undefined && cert.purposes.length > 0) {\n      exts.push({\n        oid: EXTS.basicConstraints,\n        critical: true\n      });\n      exts.push({\n        oid: EXTS.keyUsage,\n        critical: true\n      });\n      exts.push({\n        oid: EXTS.extKeyUsage,\n        critical: true\n      });\n    }\n    exts.push({\n      oid: EXTS.altName\n    });\n    if (sig.extras && sig.extras.exts) exts = sig.extras.exts;\n    for (var i = 0; i < exts.length; ++i) {\n      der.startSequence();\n      der.writeOID(exts[i].oid);\n      if (exts[i].critical !== undefined) der.writeBoolean(exts[i].critical);\n      if (exts[i].oid === EXTS.altName) {\n        der.startSequence(asn1.Ber.OctetString);\n        der.startSequence();\n        if (subject.type === 'host') {\n          der.writeString(subject.hostname, Context(2));\n        }\n        for (var j = 0; j < altNames.length; ++j) {\n          if (altNames[j].type === 'host') {\n            der.writeString(altNames[j].hostname, ALTNAME.DNSName);\n          } else if (altNames[j].type === 'email') {\n            der.writeString(altNames[j].email, ALTNAME.RFC822Name);\n          } else {\n            /*\n             * Encode anything else as a\n             * DN style name for now.\n             */\n            der.startSequence(ALTNAME.DirectoryName);\n            altNames[j].toAsn1(der);\n            der.endSequence();\n          }\n        }\n        der.endSequence();\n        der.endSequence();\n      } else if (exts[i].oid === EXTS.basicConstraints) {\n        der.startSequence(asn1.Ber.OctetString);\n        der.startSequence();\n        var ca = cert.purposes.indexOf('ca') !== -1;\n        var pathLen = exts[i].pathLen;\n        der.writeBoolean(ca);\n        if (pathLen !== undefined) der.writeInt(pathLen);\n        der.endSequence();\n        der.endSequence();\n      } else if (exts[i].oid === EXTS.extKeyUsage) {\n        der.startSequence(asn1.Ber.OctetString);\n        der.startSequence();\n        cert.purposes.forEach(function (purpose) {\n          if (purpose === 'ca') return;\n          if (KEYUSEBITS.indexOf(purpose) !== -1) return;\n          var oid = purpose;\n          if (EXTPURPOSE[purpose] !== undefined) oid = EXTPURPOSE[purpose];\n          der.writeOID(oid);\n        });\n        der.endSequence();\n        der.endSequence();\n      } else if (exts[i].oid === EXTS.keyUsage) {\n        der.startSequence(asn1.Ber.OctetString);\n        /*\n         * If we parsed this certificate from a byte\n         * stream (i.e. we didn't generate it in sshpk)\n         * then we'll have a \".bits\" property on the\n         * ext with the original raw byte contents.\n         *\n         * If we have this, use it here instead of\n         * regenerating it. This guarantees we output\n         * the same data we parsed, so signatures still\n         * validate.\n         */\n        if (exts[i].bits !== undefined) {\n          der.writeBuffer(exts[i].bits, asn1.Ber.BitString);\n        } else {\n          var bits = writeBitField(cert.purposes, KEYUSEBITS);\n          der.writeBuffer(bits, asn1.Ber.BitString);\n        }\n        der.endSequence();\n      } else {\n        der.writeBuffer(exts[i].data, asn1.Ber.OctetString);\n      }\n      der.endSequence();\n    }\n    der.endSequence();\n    der.endSequence();\n  }\n  der.endSequence();\n}\n\n/*\n * Reads an ASN.1 BER bitfield out of the Buffer produced by doing\n * `BerReader#readString(asn1.Ber.BitString)`. That function gives us the raw\n * contents of the BitString tag, which is a count of unused bits followed by\n * the bits as a right-padded byte string.\n *\n * `bits` is the Buffer, `bitIndex` should contain an array of string names\n * for the bits in the string, ordered starting with bit #0 in the ASN.1 spec.\n *\n * Returns an array of Strings, the names of the bits that were set to 1.\n */\nfunction readBitField(bits, bitIndex) {\n  var bitLen = 8 * (bits.length - 1) - bits[0];\n  var setBits = {};\n  for (var i = 0; i < bitLen; ++i) {\n    var byteN = 1 + Math.floor(i / 8);\n    var bit = 7 - i % 8;\n    var mask = 1 << bit;\n    var bitVal = (bits[byteN] & mask) !== 0;\n    var name = bitIndex[i];\n    if (bitVal && typeof name === 'string') {\n      setBits[name] = true;\n    }\n  }\n  return Object.keys(setBits);\n}\n\n/*\n * `setBits` is an array of strings, containing the names for each bit that\n * sould be set to 1. `bitIndex` is same as in `readBitField()`.\n *\n * Returns a Buffer, ready to be written out with `BerWriter#writeString()`.\n */\nfunction writeBitField(setBits, bitIndex) {\n  var bitLen = bitIndex.length;\n  var blen = Math.ceil(bitLen / 8);\n  var unused = blen * 8 - bitLen;\n  var bits = Buffer.alloc(1 + blen); // zero-filled\n  bits[0] = unused;\n  for (var i = 0; i < bitLen; ++i) {\n    var byteN = 1 + Math.floor(i / 8);\n    var bit = 7 - i % 8;\n    var mask = 1 << bit;\n    var name = bitIndex[i];\n    if (name === undefined) continue;\n    var bitVal = setBits.indexOf(name) !== -1;\n    if (bitVal) {\n      bits[byteN] |= mask;\n    }\n  }\n  return bits;\n}","map":{"version":3,"names":["module","exports","read","verify","sign","signAsync","write","assert","require","asn1","Buffer","algs","utils","Key","PrivateKey","pem","Identity","Signature","Certificate","pkcs8","readMPInt","der","nm","strictEqual","peek","Ber","Integer","mpNormalize","readString","cert","key","sig","signatures","x509","object","algParts","algo","split","type","blob","cache","undefined","BerWriter","writeTBSCert","buffer","verifier","createVerify","signature","Local","i","Context","Constructor","SIGN_ALGS","Object","keys","forEach","k","EXTS","buf","options","from","BerReader","readSequence","Math","abs","length","remain","Error","tbsStart","offset","sigOffset","tbsEnd","version","readInt","ok","extras","serial","after","certAlgOid","readOID","certAlg","_offset","issuer","parseAsn1","validFrom","readDate","validUntil","subjects","subjectKey","readPkcs8","issuerUniqueID","slice","subjectUniqueID","extEnd","readExtension","sigAlgOid","sigAlg","sigData","BitString","parse","hashAlgorithm","UTCTime","utcTimeToDate","GeneralizedTime","gTimeToDate","writeDate","date","getUTCFullYear","writeString","dateToGTime","dateToUTCTime","ALTNAME","OtherName","RFC822Name","DNSName","X400Address","DirectoryName","EDIPartyName","URI","IPAddress","OID","EXTPURPOSE","EXTPURPOSE_REV","KEYUSEBITS","extId","id","exts","critical","Boolean","readBoolean","basicConstraints","OctetString","bcEnd","ca","purposes","push","bc","oid","pathLen","extKeyUsage","ekEnd","indexOf","ide","hostname","uid","email","components","value","keyUsage","bits","setBits","readBitField","bit","altName","aeEnd","forEmail","equals","host","forHost","data","UTCTIME_RE","t","m","match","d","Date","thisYear","century","floor","year","parseInt","setUTCFullYear","setUTCHours","setUTCSeconds","GTIME_RE","zeroPad","n","s","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","defaultHashAlgorithm","signer","createSign","done","err","startSequence","_ensure","copy","_buf","writeOID","writeNull","endSequence","toBuffer","alloc","writeBuffer","writeInt","toAsn1","subject","altNames","writePkcs8","writeBoolean","j","purpose","writeBitField","bitIndex","bitLen","byteN","mask","bitVal","name","blen","ceil","unused"],"sources":["/Users/mohitgupta/Downloads/orgs/Clone/inst/node_modules/sshpk/lib/formats/x509.js"],"sourcesContent":["// Copyright 2017 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\tverify: verify,\n\tsign: sign,\n\tsignAsync: signAsync,\n\twrite: write\n};\n\nvar assert = require('assert-plus');\nvar asn1 = require('asn1');\nvar Buffer = require('safer-buffer').Buffer;\nvar algs = require('../algs');\nvar utils = require('../utils');\nvar Key = require('../key');\nvar PrivateKey = require('../private-key');\nvar pem = require('./pem');\nvar Identity = require('../identity');\nvar Signature = require('../signature');\nvar Certificate = require('../certificate');\nvar pkcs8 = require('./pkcs8');\n\n/*\n * This file is based on RFC5280 (X.509).\n */\n\n/* Helper to read in a single mpint */\nfunction readMPInt(der, nm) {\n\tassert.strictEqual(der.peek(), asn1.Ber.Integer,\n\t    nm + ' is not an Integer');\n\treturn (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));\n}\n\nfunction verify(cert, key) {\n\tvar sig = cert.signatures.x509;\n\tassert.object(sig, 'x509 signature');\n\n\tvar algParts = sig.algo.split('-');\n\tif (algParts[0] !== key.type)\n\t\treturn (false);\n\n\tvar blob = sig.cache;\n\tif (blob === undefined) {\n\t\tvar der = new asn1.BerWriter();\n\t\twriteTBSCert(cert, der);\n\t\tblob = der.buffer;\n\t}\n\n\tvar verifier = key.createVerify(algParts[1]);\n\tverifier.write(blob);\n\treturn (verifier.verify(sig.signature));\n}\n\nfunction Local(i) {\n\treturn (asn1.Ber.Context | asn1.Ber.Constructor | i);\n}\n\nfunction Context(i) {\n\treturn (asn1.Ber.Context | i);\n}\n\nvar SIGN_ALGS = {\n\t'rsa-md5': '1.2.840.113549.1.1.4',\n\t'rsa-sha1': '1.2.840.113549.1.1.5',\n\t'rsa-sha256': '1.2.840.113549.1.1.11',\n\t'rsa-sha384': '1.2.840.113549.1.1.12',\n\t'rsa-sha512': '1.2.840.113549.1.1.13',\n\t'dsa-sha1': '1.2.840.10040.4.3',\n\t'dsa-sha256': '2.16.840.1.101.3.4.3.2',\n\t'ecdsa-sha1': '1.2.840.10045.4.1',\n\t'ecdsa-sha256': '1.2.840.10045.4.3.2',\n\t'ecdsa-sha384': '1.2.840.10045.4.3.3',\n\t'ecdsa-sha512': '1.2.840.10045.4.3.4',\n\t'ed25519-sha512': '1.3.101.112'\n};\nObject.keys(SIGN_ALGS).forEach(function (k) {\n\tSIGN_ALGS[SIGN_ALGS[k]] = k;\n});\nSIGN_ALGS['1.3.14.3.2.3'] = 'rsa-md5';\nSIGN_ALGS['1.3.14.3.2.29'] = 'rsa-sha1';\n\nvar EXTS = {\n\t'issuerKeyId': '2.5.29.35',\n\t'altName': '2.5.29.17',\n\t'basicConstraints': '2.5.29.19',\n\t'keyUsage': '2.5.29.15',\n\t'extKeyUsage': '2.5.29.37'\n};\n\nfunction read(buf, options) {\n\tif (typeof (buf) === 'string') {\n\t\tbuf = Buffer.from(buf, 'binary');\n\t}\n\tassert.buffer(buf, 'buf');\n\n\tvar der = new asn1.BerReader(buf);\n\n\tder.readSequence();\n\tif (Math.abs(der.length - der.remain) > 1) {\n\t\tthrow (new Error('DER sequence does not contain whole byte ' +\n\t\t    'stream'));\n\t}\n\n\tvar tbsStart = der.offset;\n\tder.readSequence();\n\tvar sigOffset = der.offset + der.length;\n\tvar tbsEnd = sigOffset;\n\n\tif (der.peek() === Local(0)) {\n\t\tder.readSequence(Local(0));\n\t\tvar version = der.readInt();\n\t\tassert.ok(version <= 3,\n\t\t    'only x.509 versions up to v3 supported');\n\t}\n\n\tvar cert = {};\n\tcert.signatures = {};\n\tvar sig = (cert.signatures.x509 = {});\n\tsig.extras = {};\n\n\tcert.serial = readMPInt(der, 'serial');\n\n\tder.readSequence();\n\tvar after = der.offset + der.length;\n\tvar certAlgOid = der.readOID();\n\tvar certAlg = SIGN_ALGS[certAlgOid];\n\tif (certAlg === undefined)\n\t\tthrow (new Error('unknown signature algorithm ' + certAlgOid));\n\n\tder._offset = after;\n\tcert.issuer = Identity.parseAsn1(der);\n\n\tder.readSequence();\n\tcert.validFrom = readDate(der);\n\tcert.validUntil = readDate(der);\n\n\tcert.subjects = [Identity.parseAsn1(der)];\n\n\tder.readSequence();\n\tafter = der.offset + der.length;\n\tcert.subjectKey = pkcs8.readPkcs8(undefined, 'public', der);\n\tder._offset = after;\n\n\t/* issuerUniqueID */\n\tif (der.peek() === Local(1)) {\n\t\tder.readSequence(Local(1));\n\t\tsig.extras.issuerUniqueID =\n\t\t    buf.slice(der.offset, der.offset + der.length);\n\t\tder._offset += der.length;\n\t}\n\n\t/* subjectUniqueID */\n\tif (der.peek() === Local(2)) {\n\t\tder.readSequence(Local(2));\n\t\tsig.extras.subjectUniqueID =\n\t\t    buf.slice(der.offset, der.offset + der.length);\n\t\tder._offset += der.length;\n\t}\n\n\t/* extensions */\n\tif (der.peek() === Local(3)) {\n\t\tder.readSequence(Local(3));\n\t\tvar extEnd = der.offset + der.length;\n\t\tder.readSequence();\n\n\t\twhile (der.offset < extEnd)\n\t\t\treadExtension(cert, buf, der);\n\n\t\tassert.strictEqual(der.offset, extEnd);\n\t}\n\n\tassert.strictEqual(der.offset, sigOffset);\n\n\tder.readSequence();\n\tafter = der.offset + der.length;\n\tvar sigAlgOid = der.readOID();\n\tvar sigAlg = SIGN_ALGS[sigAlgOid];\n\tif (sigAlg === undefined)\n\t\tthrow (new Error('unknown signature algorithm ' + sigAlgOid));\n\tder._offset = after;\n\n\tvar sigData = der.readString(asn1.Ber.BitString, true);\n\tif (sigData[0] === 0)\n\t\tsigData = sigData.slice(1);\n\tvar algParts = sigAlg.split('-');\n\n\tsig.signature = Signature.parse(sigData, algParts[0], 'asn1');\n\tsig.signature.hashAlgorithm = algParts[1];\n\tsig.algo = sigAlg;\n\tsig.cache = buf.slice(tbsStart, tbsEnd);\n\n\treturn (new Certificate(cert));\n}\n\nfunction readDate(der) {\n\tif (der.peek() === asn1.Ber.UTCTime) {\n\t\treturn (utcTimeToDate(der.readString(asn1.Ber.UTCTime)));\n\t} else if (der.peek() === asn1.Ber.GeneralizedTime) {\n\t\treturn (gTimeToDate(der.readString(asn1.Ber.GeneralizedTime)));\n\t} else {\n\t\tthrow (new Error('Unsupported date format'));\n\t}\n}\n\nfunction writeDate(der, date) {\n\tif (date.getUTCFullYear() >= 2050 || date.getUTCFullYear() < 1950) {\n\t\tder.writeString(dateToGTime(date), asn1.Ber.GeneralizedTime);\n\t} else {\n\t\tder.writeString(dateToUTCTime(date), asn1.Ber.UTCTime);\n\t}\n}\n\n/* RFC5280, section 4.2.1.6 (GeneralName type) */\nvar ALTNAME = {\n\tOtherName: Local(0),\n\tRFC822Name: Context(1),\n\tDNSName: Context(2),\n\tX400Address: Local(3),\n\tDirectoryName: Local(4),\n\tEDIPartyName: Local(5),\n\tURI: Context(6),\n\tIPAddress: Context(7),\n\tOID: Context(8)\n};\n\n/* RFC5280, section 4.2.1.12 (KeyPurposeId) */\nvar EXTPURPOSE = {\n\t'serverAuth': '1.3.6.1.5.5.7.3.1',\n\t'clientAuth': '1.3.6.1.5.5.7.3.2',\n\t'codeSigning': '1.3.6.1.5.5.7.3.3',\n\n\t/* See https://github.com/joyent/oid-docs/blob/master/root.md */\n\t'joyentDocker': '1.3.6.1.4.1.38678.1.4.1',\n\t'joyentCmon': '1.3.6.1.4.1.38678.1.4.2'\n};\nvar EXTPURPOSE_REV = {};\nObject.keys(EXTPURPOSE).forEach(function (k) {\n\tEXTPURPOSE_REV[EXTPURPOSE[k]] = k;\n});\n\nvar KEYUSEBITS = [\n\t'signature', 'identity', 'keyEncryption',\n\t'encryption', 'keyAgreement', 'ca', 'crl'\n];\n\nfunction readExtension(cert, buf, der) {\n\tder.readSequence();\n\tvar after = der.offset + der.length;\n\tvar extId = der.readOID();\n\tvar id;\n\tvar sig = cert.signatures.x509;\n\tif (!sig.extras.exts)\n\t\tsig.extras.exts = [];\n\n\tvar critical;\n\tif (der.peek() === asn1.Ber.Boolean)\n\t\tcritical = der.readBoolean();\n\n\tswitch (extId) {\n\tcase (EXTS.basicConstraints):\n\t\tder.readSequence(asn1.Ber.OctetString);\n\t\tder.readSequence();\n\t\tvar bcEnd = der.offset + der.length;\n\t\tvar ca = false;\n\t\tif (der.peek() === asn1.Ber.Boolean)\n\t\t\tca = der.readBoolean();\n\t\tif (cert.purposes === undefined)\n\t\t\tcert.purposes = [];\n\t\tif (ca === true)\n\t\t\tcert.purposes.push('ca');\n\t\tvar bc = { oid: extId, critical: critical };\n\t\tif (der.offset < bcEnd && der.peek() === asn1.Ber.Integer)\n\t\t\tbc.pathLen = der.readInt();\n\t\tsig.extras.exts.push(bc);\n\t\tbreak;\n\tcase (EXTS.extKeyUsage):\n\t\tder.readSequence(asn1.Ber.OctetString);\n\t\tder.readSequence();\n\t\tif (cert.purposes === undefined)\n\t\t\tcert.purposes = [];\n\t\tvar ekEnd = der.offset + der.length;\n\t\twhile (der.offset < ekEnd) {\n\t\t\tvar oid = der.readOID();\n\t\t\tcert.purposes.push(EXTPURPOSE_REV[oid] || oid);\n\t\t}\n\t\t/*\n\t\t * This is a bit of a hack: in the case where we have a cert\n\t\t * that's only allowed to do serverAuth or clientAuth (and not\n\t\t * the other), we want to make sure all our Subjects are of\n\t\t * the right type. But we already parsed our Subjects and\n\t\t * decided if they were hosts or users earlier (since it appears\n\t\t * first in the cert).\n\t\t *\n\t\t * So we go through and mutate them into the right kind here if\n\t\t * it doesn't match. This might not be hugely beneficial, as it\n\t\t * seems that single-purpose certs are not often seen in the\n\t\t * wild.\n\t\t */\n\t\tif (cert.purposes.indexOf('serverAuth') !== -1 &&\n\t\t    cert.purposes.indexOf('clientAuth') === -1) {\n\t\t\tcert.subjects.forEach(function (ide) {\n\t\t\t\tif (ide.type !== 'host') {\n\t\t\t\t\tide.type = 'host';\n\t\t\t\t\tide.hostname = ide.uid ||\n\t\t\t\t\t    ide.email ||\n\t\t\t\t\t    ide.components[0].value;\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (cert.purposes.indexOf('clientAuth') !== -1 &&\n\t\t    cert.purposes.indexOf('serverAuth') === -1) {\n\t\t\tcert.subjects.forEach(function (ide) {\n\t\t\t\tif (ide.type !== 'user') {\n\t\t\t\t\tide.type = 'user';\n\t\t\t\t\tide.uid = ide.hostname ||\n\t\t\t\t\t    ide.email ||\n\t\t\t\t\t    ide.components[0].value;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tsig.extras.exts.push({ oid: extId, critical: critical });\n\t\tbreak;\n\tcase (EXTS.keyUsage):\n\t\tder.readSequence(asn1.Ber.OctetString);\n\t\tvar bits = der.readString(asn1.Ber.BitString, true);\n\t\tvar setBits = readBitField(bits, KEYUSEBITS);\n\t\tsetBits.forEach(function (bit) {\n\t\t\tif (cert.purposes === undefined)\n\t\t\t\tcert.purposes = [];\n\t\t\tif (cert.purposes.indexOf(bit) === -1)\n\t\t\t\tcert.purposes.push(bit);\n\t\t});\n\t\tsig.extras.exts.push({ oid: extId, critical: critical,\n\t\t    bits: bits });\n\t\tbreak;\n\tcase (EXTS.altName):\n\t\tder.readSequence(asn1.Ber.OctetString);\n\t\tder.readSequence();\n\t\tvar aeEnd = der.offset + der.length;\n\t\twhile (der.offset < aeEnd) {\n\t\t\tswitch (der.peek()) {\n\t\t\tcase ALTNAME.OtherName:\n\t\t\tcase ALTNAME.EDIPartyName:\n\t\t\t\tder.readSequence();\n\t\t\t\tder._offset += der.length;\n\t\t\t\tbreak;\n\t\t\tcase ALTNAME.OID:\n\t\t\t\tder.readOID(ALTNAME.OID);\n\t\t\t\tbreak;\n\t\t\tcase ALTNAME.RFC822Name:\n\t\t\t\t/* RFC822 specifies email addresses */\n\t\t\t\tvar email = der.readString(ALTNAME.RFC822Name);\n\t\t\t\tid = Identity.forEmail(email);\n\t\t\t\tif (!cert.subjects[0].equals(id))\n\t\t\t\t\tcert.subjects.push(id);\n\t\t\t\tbreak;\n\t\t\tcase ALTNAME.DirectoryName:\n\t\t\t\tder.readSequence(ALTNAME.DirectoryName);\n\t\t\t\tid = Identity.parseAsn1(der);\n\t\t\t\tif (!cert.subjects[0].equals(id))\n\t\t\t\t\tcert.subjects.push(id);\n\t\t\t\tbreak;\n\t\t\tcase ALTNAME.DNSName:\n\t\t\t\tvar host = der.readString(\n\t\t\t\t    ALTNAME.DNSName);\n\t\t\t\tid = Identity.forHost(host);\n\t\t\t\tif (!cert.subjects[0].equals(id))\n\t\t\t\t\tcert.subjects.push(id);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tder.readString(der.peek());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsig.extras.exts.push({ oid: extId, critical: critical });\n\t\tbreak;\n\tdefault:\n\t\tsig.extras.exts.push({\n\t\t\toid: extId,\n\t\t\tcritical: critical,\n\t\t\tdata: der.readString(asn1.Ber.OctetString, true)\n\t\t});\n\t\tbreak;\n\t}\n\n\tder._offset = after;\n}\n\nvar UTCTIME_RE =\n    /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;\nfunction utcTimeToDate(t) {\n\tvar m = t.match(UTCTIME_RE);\n\tassert.ok(m, 'timestamps must be in UTC');\n\tvar d = new Date();\n\n\tvar thisYear = d.getUTCFullYear();\n\tvar century = Math.floor(thisYear / 100) * 100;\n\n\tvar year = parseInt(m[1], 10);\n\tif (thisYear % 100 < 50 && year >= 60)\n\t\tyear += (century - 1);\n\telse\n\t\tyear += century;\n\td.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));\n\td.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));\n\tif (m[6] && m[6].length > 0)\n\t\td.setUTCSeconds(parseInt(m[6], 10));\n\treturn (d);\n}\n\nvar GTIME_RE =\n    /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;\nfunction gTimeToDate(t) {\n\tvar m = t.match(GTIME_RE);\n\tassert.ok(m);\n\tvar d = new Date();\n\n\td.setUTCFullYear(parseInt(m[1], 10), parseInt(m[2], 10) - 1,\n\t    parseInt(m[3], 10));\n\td.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));\n\tif (m[6] && m[6].length > 0)\n\t\td.setUTCSeconds(parseInt(m[6], 10));\n\treturn (d);\n}\n\nfunction zeroPad(n, m) {\n\tif (m === undefined)\n\t\tm = 2;\n\tvar s = '' + n;\n\twhile (s.length < m)\n\t\ts = '0' + s;\n\treturn (s);\n}\n\nfunction dateToUTCTime(d) {\n\tvar s = '';\n\ts += zeroPad(d.getUTCFullYear() % 100);\n\ts += zeroPad(d.getUTCMonth() + 1);\n\ts += zeroPad(d.getUTCDate());\n\ts += zeroPad(d.getUTCHours());\n\ts += zeroPad(d.getUTCMinutes());\n\ts += zeroPad(d.getUTCSeconds());\n\ts += 'Z';\n\treturn (s);\n}\n\nfunction dateToGTime(d) {\n\tvar s = '';\n\ts += zeroPad(d.getUTCFullYear(), 4);\n\ts += zeroPad(d.getUTCMonth() + 1);\n\ts += zeroPad(d.getUTCDate());\n\ts += zeroPad(d.getUTCHours());\n\ts += zeroPad(d.getUTCMinutes());\n\ts += zeroPad(d.getUTCSeconds());\n\ts += 'Z';\n\treturn (s);\n}\n\nfunction sign(cert, key) {\n\tif (cert.signatures.x509 === undefined)\n\t\tcert.signatures.x509 = {};\n\tvar sig = cert.signatures.x509;\n\n\tsig.algo = key.type + '-' + key.defaultHashAlgorithm();\n\tif (SIGN_ALGS[sig.algo] === undefined)\n\t\treturn (false);\n\n\tvar der = new asn1.BerWriter();\n\twriteTBSCert(cert, der);\n\tvar blob = der.buffer;\n\tsig.cache = blob;\n\n\tvar signer = key.createSign();\n\tsigner.write(blob);\n\tcert.signatures.x509.signature = signer.sign();\n\n\treturn (true);\n}\n\nfunction signAsync(cert, signer, done) {\n\tif (cert.signatures.x509 === undefined)\n\t\tcert.signatures.x509 = {};\n\tvar sig = cert.signatures.x509;\n\n\tvar der = new asn1.BerWriter();\n\twriteTBSCert(cert, der);\n\tvar blob = der.buffer;\n\tsig.cache = blob;\n\n\tsigner(blob, function (err, signature) {\n\t\tif (err) {\n\t\t\tdone(err);\n\t\t\treturn;\n\t\t}\n\t\tsig.algo = signature.type + '-' + signature.hashAlgorithm;\n\t\tif (SIGN_ALGS[sig.algo] === undefined) {\n\t\t\tdone(new Error('Invalid signing algorithm \"' +\n\t\t\t    sig.algo + '\"'));\n\t\t\treturn;\n\t\t}\n\t\tsig.signature = signature;\n\t\tdone();\n\t});\n}\n\nfunction write(cert, options) {\n\tvar sig = cert.signatures.x509;\n\tassert.object(sig, 'x509 signature');\n\n\tvar der = new asn1.BerWriter();\n\tder.startSequence();\n\tif (sig.cache) {\n\t\tder._ensure(sig.cache.length);\n\t\tsig.cache.copy(der._buf, der._offset);\n\t\tder._offset += sig.cache.length;\n\t} else {\n\t\twriteTBSCert(cert, der);\n\t}\n\n\tder.startSequence();\n\tder.writeOID(SIGN_ALGS[sig.algo]);\n\tif (sig.algo.match(/^rsa-/))\n\t\tder.writeNull();\n\tder.endSequence();\n\n\tvar sigData = sig.signature.toBuffer('asn1');\n\tvar data = Buffer.alloc(sigData.length + 1);\n\tdata[0] = 0;\n\tsigData.copy(data, 1);\n\tder.writeBuffer(data, asn1.Ber.BitString);\n\tder.endSequence();\n\n\treturn (der.buffer);\n}\n\nfunction writeTBSCert(cert, der) {\n\tvar sig = cert.signatures.x509;\n\tassert.object(sig, 'x509 signature');\n\n\tder.startSequence();\n\n\tder.startSequence(Local(0));\n\tder.writeInt(2);\n\tder.endSequence();\n\n\tder.writeBuffer(utils.mpNormalize(cert.serial), asn1.Ber.Integer);\n\n\tder.startSequence();\n\tder.writeOID(SIGN_ALGS[sig.algo]);\n\tif (sig.algo.match(/^rsa-/))\n\t\tder.writeNull();\n\tder.endSequence();\n\n\tcert.issuer.toAsn1(der);\n\n\tder.startSequence();\n\twriteDate(der, cert.validFrom);\n\twriteDate(der, cert.validUntil);\n\tder.endSequence();\n\n\tvar subject = cert.subjects[0];\n\tvar altNames = cert.subjects.slice(1);\n\tsubject.toAsn1(der);\n\n\tpkcs8.writePkcs8(der, cert.subjectKey);\n\n\tif (sig.extras && sig.extras.issuerUniqueID) {\n\t\tder.writeBuffer(sig.extras.issuerUniqueID, Local(1));\n\t}\n\n\tif (sig.extras && sig.extras.subjectUniqueID) {\n\t\tder.writeBuffer(sig.extras.subjectUniqueID, Local(2));\n\t}\n\n\tif (altNames.length > 0 || subject.type === 'host' ||\n\t    (cert.purposes !== undefined && cert.purposes.length > 0) ||\n\t    (sig.extras && sig.extras.exts)) {\n\t\tder.startSequence(Local(3));\n\t\tder.startSequence();\n\n\t\tvar exts = [];\n\t\tif (cert.purposes !== undefined && cert.purposes.length > 0) {\n\t\t\texts.push({\n\t\t\t\toid: EXTS.basicConstraints,\n\t\t\t\tcritical: true\n\t\t\t});\n\t\t\texts.push({\n\t\t\t\toid: EXTS.keyUsage,\n\t\t\t\tcritical: true\n\t\t\t});\n\t\t\texts.push({\n\t\t\t\toid: EXTS.extKeyUsage,\n\t\t\t\tcritical: true\n\t\t\t});\n\t\t}\n\t\texts.push({ oid: EXTS.altName });\n\t\tif (sig.extras && sig.extras.exts)\n\t\t\texts = sig.extras.exts;\n\n\t\tfor (var i = 0; i < exts.length; ++i) {\n\t\t\tder.startSequence();\n\t\t\tder.writeOID(exts[i].oid);\n\n\t\t\tif (exts[i].critical !== undefined)\n\t\t\t\tder.writeBoolean(exts[i].critical);\n\n\t\t\tif (exts[i].oid === EXTS.altName) {\n\t\t\t\tder.startSequence(asn1.Ber.OctetString);\n\t\t\t\tder.startSequence();\n\t\t\t\tif (subject.type === 'host') {\n\t\t\t\t\tder.writeString(subject.hostname,\n\t\t\t\t\t    Context(2));\n\t\t\t\t}\n\t\t\t\tfor (var j = 0; j < altNames.length; ++j) {\n\t\t\t\t\tif (altNames[j].type === 'host') {\n\t\t\t\t\t\tder.writeString(\n\t\t\t\t\t\t    altNames[j].hostname,\n\t\t\t\t\t\t    ALTNAME.DNSName);\n\t\t\t\t\t} else if (altNames[j].type ===\n\t\t\t\t\t    'email') {\n\t\t\t\t\t\tder.writeString(\n\t\t\t\t\t\t    altNames[j].email,\n\t\t\t\t\t\t    ALTNAME.RFC822Name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Encode anything else as a\n\t\t\t\t\t\t * DN style name for now.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tder.startSequence(\n\t\t\t\t\t\t    ALTNAME.DirectoryName);\n\t\t\t\t\t\taltNames[j].toAsn1(der);\n\t\t\t\t\t\tder.endSequence();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tder.endSequence();\n\t\t\t\tder.endSequence();\n\t\t\t} else if (exts[i].oid === EXTS.basicConstraints) {\n\t\t\t\tder.startSequence(asn1.Ber.OctetString);\n\t\t\t\tder.startSequence();\n\t\t\t\tvar ca = (cert.purposes.indexOf('ca') !== -1);\n\t\t\t\tvar pathLen = exts[i].pathLen;\n\t\t\t\tder.writeBoolean(ca);\n\t\t\t\tif (pathLen !== undefined)\n\t\t\t\t\tder.writeInt(pathLen);\n\t\t\t\tder.endSequence();\n\t\t\t\tder.endSequence();\n\t\t\t} else if (exts[i].oid === EXTS.extKeyUsage) {\n\t\t\t\tder.startSequence(asn1.Ber.OctetString);\n\t\t\t\tder.startSequence();\n\t\t\t\tcert.purposes.forEach(function (purpose) {\n\t\t\t\t\tif (purpose === 'ca')\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif (KEYUSEBITS.indexOf(purpose) !== -1)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tvar oid = purpose;\n\t\t\t\t\tif (EXTPURPOSE[purpose] !== undefined)\n\t\t\t\t\t\toid = EXTPURPOSE[purpose];\n\t\t\t\t\tder.writeOID(oid);\n\t\t\t\t});\n\t\t\t\tder.endSequence();\n\t\t\t\tder.endSequence();\n\t\t\t} else if (exts[i].oid === EXTS.keyUsage) {\n\t\t\t\tder.startSequence(asn1.Ber.OctetString);\n\t\t\t\t/*\n\t\t\t\t * If we parsed this certificate from a byte\n\t\t\t\t * stream (i.e. we didn't generate it in sshpk)\n\t\t\t\t * then we'll have a \".bits\" property on the\n\t\t\t\t * ext with the original raw byte contents.\n\t\t\t\t *\n\t\t\t\t * If we have this, use it here instead of\n\t\t\t\t * regenerating it. This guarantees we output\n\t\t\t\t * the same data we parsed, so signatures still\n\t\t\t\t * validate.\n\t\t\t\t */\n\t\t\t\tif (exts[i].bits !== undefined) {\n\t\t\t\t\tder.writeBuffer(exts[i].bits,\n\t\t\t\t\t    asn1.Ber.BitString);\n\t\t\t\t} else {\n\t\t\t\t\tvar bits = writeBitField(cert.purposes,\n\t\t\t\t\t    KEYUSEBITS);\n\t\t\t\t\tder.writeBuffer(bits,\n\t\t\t\t\t    asn1.Ber.BitString);\n\t\t\t\t}\n\t\t\t\tder.endSequence();\n\t\t\t} else {\n\t\t\t\tder.writeBuffer(exts[i].data,\n\t\t\t\t    asn1.Ber.OctetString);\n\t\t\t}\n\n\t\t\tder.endSequence();\n\t\t}\n\n\t\tder.endSequence();\n\t\tder.endSequence();\n\t}\n\n\tder.endSequence();\n}\n\n/*\n * Reads an ASN.1 BER bitfield out of the Buffer produced by doing\n * `BerReader#readString(asn1.Ber.BitString)`. That function gives us the raw\n * contents of the BitString tag, which is a count of unused bits followed by\n * the bits as a right-padded byte string.\n *\n * `bits` is the Buffer, `bitIndex` should contain an array of string names\n * for the bits in the string, ordered starting with bit #0 in the ASN.1 spec.\n *\n * Returns an array of Strings, the names of the bits that were set to 1.\n */\nfunction readBitField(bits, bitIndex) {\n\tvar bitLen = 8 * (bits.length - 1) - bits[0];\n\tvar setBits = {};\n\tfor (var i = 0; i < bitLen; ++i) {\n\t\tvar byteN = 1 + Math.floor(i / 8);\n\t\tvar bit = 7 - (i % 8);\n\t\tvar mask = 1 << bit;\n\t\tvar bitVal = ((bits[byteN] & mask) !== 0);\n\t\tvar name = bitIndex[i];\n\t\tif (bitVal && typeof (name) === 'string') {\n\t\t\tsetBits[name] = true;\n\t\t}\n\t}\n\treturn (Object.keys(setBits));\n}\n\n/*\n * `setBits` is an array of strings, containing the names for each bit that\n * sould be set to 1. `bitIndex` is same as in `readBitField()`.\n *\n * Returns a Buffer, ready to be written out with `BerWriter#writeString()`.\n */\nfunction writeBitField(setBits, bitIndex) {\n\tvar bitLen = bitIndex.length;\n\tvar blen = Math.ceil(bitLen / 8);\n\tvar unused = blen * 8 - bitLen;\n\tvar bits = Buffer.alloc(1 + blen); // zero-filled\n\tbits[0] = unused;\n\tfor (var i = 0; i < bitLen; ++i) {\n\t\tvar byteN = 1 + Math.floor(i / 8);\n\t\tvar bit = 7 - (i % 8);\n\t\tvar mask = 1 << bit;\n\t\tvar name = bitIndex[i];\n\t\tif (name === undefined)\n\t\t\tcontinue;\n\t\tvar bitVal = (setBits.indexOf(name) !== -1);\n\t\tif (bitVal) {\n\t\t\tbits[byteN] |= mask;\n\t\t}\n\t}\n\treturn (bits);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}