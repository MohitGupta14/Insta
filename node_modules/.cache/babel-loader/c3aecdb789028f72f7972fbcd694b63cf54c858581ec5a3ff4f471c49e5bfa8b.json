{"ast":null,"code":"/*\n * extsprintf.js: extended POSIX-style sprintf\n */\n\nvar mod_assert = require('assert');\nvar mod_util = require('util');\n\n/*\n * Public interface\n */\nexports.sprintf = jsSprintf;\nexports.printf = jsPrintf;\nexports.fprintf = jsFprintf;\n\n/*\n * Stripped down version of s[n]printf(3c).  We make a best effort to throw an\n * exception when given a format string we don't understand, rather than\n * ignoring it, so that we won't break existing programs if/when we go implement\n * the rest of this.\n *\n * This implementation currently supports specifying\n *\t- field alignment ('-' flag),\n * \t- zero-pad ('0' flag)\n *\t- always show numeric sign ('+' flag),\n *\t- field width\n *\t- conversions for strings, decimal integers, and floats (numbers).\n *\t- argument size specifiers.  These are all accepted but ignored, since\n *\t  Javascript has no notion of the physical size of an argument.\n *\n * Everything else is currently unsupported, most notably precision, unsigned\n * numbers, non-decimal numbers, and characters.\n */\nfunction jsSprintf(ofmt) {\n  var regex = ['([^%]*)', /* normal text */\n  '%', /* start of format */\n  '([\\'\\\\-+ #0]*?)', /* flags (optional) */\n  '([1-9]\\\\d*)?', /* width (optional) */\n  '(\\\\.([1-9]\\\\d*))?', /* precision (optional) */\n  '[lhjztL]*?', /* length mods (ignored) */\n  '([diouxXfFeEgGaAcCsSp%jr])' /* conversion */].join('');\n  var re = new RegExp(regex);\n\n  /* variadic arguments used to fill in conversion specifiers */\n  var args = Array.prototype.slice.call(arguments, 1);\n  /* remaining format string */\n  var fmt = ofmt;\n\n  /* components of the current conversion specifier */\n  var flags, width, precision, conversion;\n  var left, pad, sign, arg, match;\n\n  /* return value */\n  var ret = '';\n\n  /* current variadic argument (1-based) */\n  var argn = 1;\n  /* 0-based position in the format string that we've read */\n  var posn = 0;\n  /* 1-based position in the format string of the current conversion */\n  var convposn;\n  /* current conversion specifier */\n  var curconv;\n  mod_assert.equal('string', typeof fmt, 'first argument must be a format string');\n  while ((match = re.exec(fmt)) !== null) {\n    ret += match[1];\n    fmt = fmt.substring(match[0].length);\n\n    /*\n     * Update flags related to the current conversion specifier's\n     * position so that we can report clear error messages.\n     */\n    curconv = match[0].substring(match[1].length);\n    convposn = posn + match[1].length + 1;\n    posn += match[0].length;\n    flags = match[2] || '';\n    width = match[3] || 0;\n    precision = match[4] || '';\n    conversion = match[6];\n    left = false;\n    sign = false;\n    pad = ' ';\n    if (conversion == '%') {\n      ret += '%';\n      continue;\n    }\n    if (args.length === 0) {\n      throw jsError(ofmt, convposn, curconv, 'has no matching argument ' + '(too few arguments passed)');\n    }\n    arg = args.shift();\n    argn++;\n    if (flags.match(/[\\' #]/)) {\n      throw jsError(ofmt, convposn, curconv, 'uses unsupported flags');\n    }\n    if (precision.length > 0) {\n      throw jsError(ofmt, convposn, curconv, 'uses non-zero precision (not supported)');\n    }\n    if (flags.match(/-/)) left = true;\n    if (flags.match(/0/)) pad = '0';\n    if (flags.match(/\\+/)) sign = true;\n    switch (conversion) {\n      case 's':\n        if (arg === undefined || arg === null) {\n          throw jsError(ofmt, convposn, curconv, 'attempted to print undefined or null ' + 'as a string (argument ' + argn + ' to ' + 'sprintf)');\n        }\n        ret += doPad(pad, width, left, arg.toString());\n        break;\n      case 'd':\n        arg = Math.floor(arg);\n      /*jsl:fallthru*/\n      case 'f':\n        sign = sign && arg > 0 ? '+' : '';\n        ret += sign + doPad(pad, width, left, arg.toString());\n        break;\n      case 'x':\n        ret += doPad(pad, width, left, arg.toString(16));\n        break;\n      case 'j':\n        /* non-standard */\n        if (width === 0) width = 10;\n        ret += mod_util.inspect(arg, false, width);\n        break;\n      case 'r':\n        /* non-standard */\n        ret += dumpException(arg);\n        break;\n      default:\n        throw jsError(ofmt, convposn, curconv, 'is not supported');\n    }\n  }\n  ret += fmt;\n  return ret;\n}\nfunction jsError(fmtstr, convposn, curconv, reason) {\n  mod_assert.equal(typeof fmtstr, 'string');\n  mod_assert.equal(typeof curconv, 'string');\n  mod_assert.equal(typeof convposn, 'number');\n  mod_assert.equal(typeof reason, 'string');\n  return new Error('format string \"' + fmtstr + '\": conversion specifier \"' + curconv + '\" at character ' + convposn + ' ' + reason);\n}\nfunction jsPrintf() {\n  var args = Array.prototype.slice.call(arguments);\n  args.unshift(process.stdout);\n  jsFprintf.apply(null, args);\n}\nfunction jsFprintf(stream) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return stream.write(jsSprintf.apply(this, args));\n}\nfunction doPad(chr, width, left, str) {\n  var ret = str;\n  while (ret.length < width) {\n    if (left) ret += chr;else ret = chr + ret;\n  }\n  return ret;\n}\n\n/*\n * This function dumps long stack traces for exceptions having a cause() method.\n * See node-verror for an example.\n */\nfunction dumpException(ex) {\n  var ret;\n  if (!(ex instanceof Error)) throw new Error(jsSprintf('invalid type for %%r: %j', ex));\n\n  /* Note that V8 prepends \"ex.stack\" with ex.toString(). */\n  ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;\n  if (ex.cause && typeof ex.cause === 'function') {\n    var cex = ex.cause();\n    if (cex) {\n      ret += '\\nCaused by: ' + dumpException(cex);\n    }\n  }\n  return ret;\n}","map":{"version":3,"names":["mod_assert","require","mod_util","exports","sprintf","jsSprintf","printf","jsPrintf","fprintf","jsFprintf","ofmt","regex","join","re","RegExp","args","Array","prototype","slice","call","arguments","fmt","flags","width","precision","conversion","left","pad","sign","arg","match","ret","argn","posn","convposn","curconv","equal","exec","substring","length","jsError","shift","undefined","doPad","toString","Math","floor","inspect","dumpException","fmtstr","reason","Error","unshift","process","stdout","apply","stream","write","chr","str","ex","constructor","name","stack","cause","cex"],"sources":["/Users/mohitgupta/Downloads/orgs/Clone/inst/node_modules/verror/node_modules/extsprintf/lib/extsprintf.js"],"sourcesContent":["/*\n * extsprintf.js: extended POSIX-style sprintf\n */\n\nvar mod_assert = require('assert');\nvar mod_util = require('util');\n\n/*\n * Public interface\n */\nexports.sprintf = jsSprintf;\nexports.printf = jsPrintf;\nexports.fprintf = jsFprintf;\n\n/*\n * Stripped down version of s[n]printf(3c).  We make a best effort to throw an\n * exception when given a format string we don't understand, rather than\n * ignoring it, so that we won't break existing programs if/when we go implement\n * the rest of this.\n *\n * This implementation currently supports specifying\n *\t- field alignment ('-' flag),\n * \t- zero-pad ('0' flag)\n *\t- always show numeric sign ('+' flag),\n *\t- field width\n *\t- conversions for strings, decimal integers, and floats (numbers).\n *\t- argument size specifiers.  These are all accepted but ignored, since\n *\t  Javascript has no notion of the physical size of an argument.\n *\n * Everything else is currently unsupported, most notably precision, unsigned\n * numbers, non-decimal numbers, and characters.\n */\nfunction jsSprintf(ofmt)\n{\n\tvar regex = [\n\t    '([^%]*)',\t\t\t\t/* normal text */\n\t    '%',\t\t\t\t/* start of format */\n\t    '([\\'\\\\-+ #0]*?)',\t\t\t/* flags (optional) */\n\t    '([1-9]\\\\d*)?',\t\t\t/* width (optional) */\n\t    '(\\\\.([1-9]\\\\d*))?',\t\t/* precision (optional) */\n\t    '[lhjztL]*?',\t\t\t/* length mods (ignored) */\n\t    '([diouxXfFeEgGaAcCsSp%jr])'\t/* conversion */\n\t].join('');\n\n\tvar re = new RegExp(regex);\n\n\t/* variadic arguments used to fill in conversion specifiers */\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\t/* remaining format string */\n\tvar fmt = ofmt;\n\n\t/* components of the current conversion specifier */\n\tvar flags, width, precision, conversion;\n\tvar left, pad, sign, arg, match;\n\n\t/* return value */\n\tvar ret = '';\n\n\t/* current variadic argument (1-based) */\n\tvar argn = 1;\n\t/* 0-based position in the format string that we've read */\n\tvar posn = 0;\n\t/* 1-based position in the format string of the current conversion */\n\tvar convposn;\n\t/* current conversion specifier */\n\tvar curconv;\n\n\tmod_assert.equal('string', typeof (fmt),\n\t    'first argument must be a format string');\n\n\twhile ((match = re.exec(fmt)) !== null) {\n\t\tret += match[1];\n\t\tfmt = fmt.substring(match[0].length);\n\n\t\t/*\n\t\t * Update flags related to the current conversion specifier's\n\t\t * position so that we can report clear error messages.\n\t\t */\n\t\tcurconv = match[0].substring(match[1].length);\n\t\tconvposn = posn + match[1].length + 1;\n\t\tposn += match[0].length;\n\n\t\tflags = match[2] || '';\n\t\twidth = match[3] || 0;\n\t\tprecision = match[4] || '';\n\t\tconversion = match[6];\n\t\tleft = false;\n\t\tsign = false;\n\t\tpad = ' ';\n\n\t\tif (conversion == '%') {\n\t\t\tret += '%';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (args.length === 0) {\n\t\t\tthrow (jsError(ofmt, convposn, curconv,\n\t\t\t    'has no matching argument ' +\n\t\t\t    '(too few arguments passed)'));\n\t\t}\n\n\t\targ = args.shift();\n\t\targn++;\n\n\t\tif (flags.match(/[\\' #]/)) {\n\t\t\tthrow (jsError(ofmt, convposn, curconv,\n\t\t\t    'uses unsupported flags'));\n\t\t}\n\n\t\tif (precision.length > 0) {\n\t\t\tthrow (jsError(ofmt, convposn, curconv,\n\t\t\t    'uses non-zero precision (not supported)'));\n\t\t}\n\n\t\tif (flags.match(/-/))\n\t\t\tleft = true;\n\n\t\tif (flags.match(/0/))\n\t\t\tpad = '0';\n\n\t\tif (flags.match(/\\+/))\n\t\t\tsign = true;\n\n\t\tswitch (conversion) {\n\t\tcase 's':\n\t\t\tif (arg === undefined || arg === null) {\n\t\t\t\tthrow (jsError(ofmt, convposn, curconv,\n\t\t\t\t    'attempted to print undefined or null ' +\n\t\t\t\t    'as a string (argument ' + argn + ' to ' +\n\t\t\t\t    'sprintf)'));\n\t\t\t}\n\t\t\tret += doPad(pad, width, left, arg.toString());\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\targ = Math.floor(arg);\n\t\t\t/*jsl:fallthru*/\n\t\tcase 'f':\n\t\t\tsign = sign && arg > 0 ? '+' : '';\n\t\t\tret += sign + doPad(pad, width, left,\n\t\t\t    arg.toString());\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\tret += doPad(pad, width, left, arg.toString(16));\n\t\t\tbreak;\n\n\t\tcase 'j': /* non-standard */\n\t\t\tif (width === 0)\n\t\t\t\twidth = 10;\n\t\t\tret += mod_util.inspect(arg, false, width);\n\t\t\tbreak;\n\n\t\tcase 'r': /* non-standard */\n\t\t\tret += dumpException(arg);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow (jsError(ofmt, convposn, curconv,\n\t\t\t    'is not supported'));\n\t\t}\n\t}\n\n\tret += fmt;\n\treturn (ret);\n}\n\nfunction jsError(fmtstr, convposn, curconv, reason) {\n\tmod_assert.equal(typeof (fmtstr), 'string');\n\tmod_assert.equal(typeof (curconv), 'string');\n\tmod_assert.equal(typeof (convposn), 'number');\n\tmod_assert.equal(typeof (reason), 'string');\n\treturn (new Error('format string \"' + fmtstr +\n\t    '\": conversion specifier \"' + curconv + '\" at character ' +\n\t    convposn + ' ' + reason));\n}\n\nfunction jsPrintf() {\n\tvar args = Array.prototype.slice.call(arguments);\n\targs.unshift(process.stdout);\n\tjsFprintf.apply(null, args);\n}\n\nfunction jsFprintf(stream) {\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\treturn (stream.write(jsSprintf.apply(this, args)));\n}\n\nfunction doPad(chr, width, left, str)\n{\n\tvar ret = str;\n\n\twhile (ret.length < width) {\n\t\tif (left)\n\t\t\tret += chr;\n\t\telse\n\t\t\tret = chr + ret;\n\t}\n\n\treturn (ret);\n}\n\n/*\n * This function dumps long stack traces for exceptions having a cause() method.\n * See node-verror for an example.\n */\nfunction dumpException(ex)\n{\n\tvar ret;\n\n\tif (!(ex instanceof Error))\n\t\tthrow (new Error(jsSprintf('invalid type for %%r: %j', ex)));\n\n\t/* Note that V8 prepends \"ex.stack\" with ex.toString(). */\n\tret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;\n\n\tif (ex.cause && typeof (ex.cause) === 'function') {\n\t\tvar cex = ex.cause();\n\t\tif (cex) {\n\t\t\tret += '\\nCaused by: ' + dumpException(cex);\n\t\t}\n\t}\n\n\treturn (ret);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}