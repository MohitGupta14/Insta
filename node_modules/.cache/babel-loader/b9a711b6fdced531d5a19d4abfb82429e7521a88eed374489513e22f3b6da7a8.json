{"ast":null,"code":"/*\n * extsprintf.js: extended POSIX-style sprintf\n */\n\nvar mod_assert = require('assert');\nvar mod_util = require('util');\n\n/*\n * Public interface\n */\nexports.sprintf = jsSprintf;\nexports.printf = jsPrintf;\nexports.fprintf = jsFprintf;\n\n/*\n * Stripped down version of s[n]printf(3c).  We make a best effort to throw an\n * exception when given a format string we don't understand, rather than\n * ignoring it, so that we won't break existing programs if/when we go implement\n * the rest of this.\n *\n * This implementation currently supports specifying\n *\t- field alignment ('-' flag),\n * \t- zero-pad ('0' flag)\n *\t- always show numeric sign ('+' flag),\n *\t- field width\n *\t- conversions for strings, decimal integers, and floats (numbers).\n *\t- argument size specifiers.  These are all accepted but ignored, since\n *\t  Javascript has no notion of the physical size of an argument.\n *\n * Everything else is currently unsupported, most notably precision, unsigned\n * numbers, non-decimal numbers, and characters.\n */\nfunction jsSprintf(fmt) {\n  var regex = ['([^%]*)', /* normal text */\n  '%', /* start of format */\n  '([\\'\\\\-+ #0]*?)', /* flags (optional) */\n  '([1-9]\\\\d*)?', /* width (optional) */\n  '(\\\\.([1-9]\\\\d*))?', /* precision (optional) */\n  '[lhjztL]*?', /* length mods (ignored) */\n  '([diouxXfFeEgGaAcCsSp%jr])' /* conversion */].join('');\n  var re = new RegExp(regex);\n  var args = Array.prototype.slice.call(arguments, 1);\n  var flags, width, precision, conversion;\n  var left, pad, sign, arg, match;\n  var ret = '';\n  var argn = 1;\n  mod_assert.equal('string', typeof fmt);\n  while ((match = re.exec(fmt)) !== null) {\n    ret += match[1];\n    fmt = fmt.substring(match[0].length);\n    flags = match[2] || '';\n    width = match[3] || 0;\n    precision = match[4] || '';\n    conversion = match[6];\n    left = false;\n    sign = false;\n    pad = ' ';\n    if (conversion == '%') {\n      ret += '%';\n      continue;\n    }\n    if (args.length === 0) throw new Error('too few args to sprintf');\n    arg = args.shift();\n    argn++;\n    if (flags.match(/[\\' #]/)) throw new Error('unsupported flags: ' + flags);\n    if (precision.length > 0) throw new Error('non-zero precision not supported');\n    if (flags.match(/-/)) left = true;\n    if (flags.match(/0/)) pad = '0';\n    if (flags.match(/\\+/)) sign = true;\n    switch (conversion) {\n      case 's':\n        if (arg === undefined || arg === null) throw new Error('argument ' + argn + ': attempted to print undefined or null ' + 'as a string');\n        ret += doPad(pad, width, left, arg.toString());\n        break;\n      case 'd':\n        arg = Math.floor(arg);\n      /*jsl:fallthru*/\n      case 'f':\n        sign = sign && arg > 0 ? '+' : '';\n        ret += sign + doPad(pad, width, left, arg.toString());\n        break;\n      case 'x':\n        ret += doPad(pad, width, left, arg.toString(16));\n        break;\n      case 'j':\n        /* non-standard */\n        if (width === 0) width = 10;\n        ret += mod_util.inspect(arg, false, width);\n        break;\n      case 'r':\n        /* non-standard */\n        ret += dumpException(arg);\n        break;\n      default:\n        throw new Error('unsupported conversion: ' + conversion);\n    }\n  }\n  ret += fmt;\n  return ret;\n}\nfunction jsPrintf() {\n  var args = Array.prototype.slice.call(arguments);\n  args.unshift(process.stdout);\n  jsFprintf.apply(null, args);\n}\nfunction jsFprintf(stream) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return stream.write(jsSprintf.apply(this, args));\n}\nfunction doPad(chr, width, left, str) {\n  var ret = str;\n  while (ret.length < width) {\n    if (left) ret += chr;else ret = chr + ret;\n  }\n  return ret;\n}\n\n/*\n * This function dumps long stack traces for exceptions having a cause() method.\n * See node-verror for an example.\n */\nfunction dumpException(ex) {\n  var ret;\n  if (!(ex instanceof Error)) throw new Error(jsSprintf('invalid type for %%r: %j', ex));\n\n  /* Note that V8 prepends \"ex.stack\" with ex.toString(). */\n  ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;\n  if (ex.cause && typeof ex.cause === 'function') {\n    var cex = ex.cause();\n    if (cex) {\n      ret += '\\nCaused by: ' + dumpException(cex);\n    }\n  }\n  return ret;\n}","map":{"version":3,"names":["mod_assert","require","mod_util","exports","sprintf","jsSprintf","printf","jsPrintf","fprintf","jsFprintf","fmt","regex","join","re","RegExp","args","Array","prototype","slice","call","arguments","flags","width","precision","conversion","left","pad","sign","arg","match","ret","argn","equal","exec","substring","length","Error","shift","undefined","doPad","toString","Math","floor","inspect","dumpException","unshift","process","stdout","apply","stream","write","chr","str","ex","constructor","name","stack","cause","cex"],"sources":["/Users/mohitgupta/Downloads/orgs/Clone/inst/node_modules/extsprintf/lib/extsprintf.js"],"sourcesContent":["/*\n * extsprintf.js: extended POSIX-style sprintf\n */\n\nvar mod_assert = require('assert');\nvar mod_util = require('util');\n\n/*\n * Public interface\n */\nexports.sprintf = jsSprintf;\nexports.printf = jsPrintf;\nexports.fprintf = jsFprintf;\n\n/*\n * Stripped down version of s[n]printf(3c).  We make a best effort to throw an\n * exception when given a format string we don't understand, rather than\n * ignoring it, so that we won't break existing programs if/when we go implement\n * the rest of this.\n *\n * This implementation currently supports specifying\n *\t- field alignment ('-' flag),\n * \t- zero-pad ('0' flag)\n *\t- always show numeric sign ('+' flag),\n *\t- field width\n *\t- conversions for strings, decimal integers, and floats (numbers).\n *\t- argument size specifiers.  These are all accepted but ignored, since\n *\t  Javascript has no notion of the physical size of an argument.\n *\n * Everything else is currently unsupported, most notably precision, unsigned\n * numbers, non-decimal numbers, and characters.\n */\nfunction jsSprintf(fmt)\n{\n\tvar regex = [\n\t    '([^%]*)',\t\t\t\t/* normal text */\n\t    '%',\t\t\t\t/* start of format */\n\t    '([\\'\\\\-+ #0]*?)',\t\t\t/* flags (optional) */\n\t    '([1-9]\\\\d*)?',\t\t\t/* width (optional) */\n\t    '(\\\\.([1-9]\\\\d*))?',\t\t/* precision (optional) */\n\t    '[lhjztL]*?',\t\t\t/* length mods (ignored) */\n\t    '([diouxXfFeEgGaAcCsSp%jr])'\t/* conversion */\n\t].join('');\n\n\tvar re = new RegExp(regex);\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\tvar flags, width, precision, conversion;\n\tvar left, pad, sign, arg, match;\n\tvar ret = '';\n\tvar argn = 1;\n\n\tmod_assert.equal('string', typeof (fmt));\n\n\twhile ((match = re.exec(fmt)) !== null) {\n\t\tret += match[1];\n\t\tfmt = fmt.substring(match[0].length);\n\n\t\tflags = match[2] || '';\n\t\twidth = match[3] || 0;\n\t\tprecision = match[4] || '';\n\t\tconversion = match[6];\n\t\tleft = false;\n\t\tsign = false;\n\t\tpad = ' ';\n\n\t\tif (conversion == '%') {\n\t\t\tret += '%';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (args.length === 0)\n\t\t\tthrow (new Error('too few args to sprintf'));\n\n\t\targ = args.shift();\n\t\targn++;\n\n\t\tif (flags.match(/[\\' #]/))\n\t\t\tthrow (new Error(\n\t\t\t    'unsupported flags: ' + flags));\n\n\t\tif (precision.length > 0)\n\t\t\tthrow (new Error(\n\t\t\t    'non-zero precision not supported'));\n\n\t\tif (flags.match(/-/))\n\t\t\tleft = true;\n\n\t\tif (flags.match(/0/))\n\t\t\tpad = '0';\n\n\t\tif (flags.match(/\\+/))\n\t\t\tsign = true;\n\n\t\tswitch (conversion) {\n\t\tcase 's':\n\t\t\tif (arg === undefined || arg === null)\n\t\t\t\tthrow (new Error('argument ' + argn +\n\t\t\t\t    ': attempted to print undefined or null ' +\n\t\t\t\t    'as a string'));\n\t\t\tret += doPad(pad, width, left, arg.toString());\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\targ = Math.floor(arg);\n\t\t\t/*jsl:fallthru*/\n\t\tcase 'f':\n\t\t\tsign = sign && arg > 0 ? '+' : '';\n\t\t\tret += sign + doPad(pad, width, left,\n\t\t\t    arg.toString());\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\tret += doPad(pad, width, left, arg.toString(16));\n\t\t\tbreak;\n\n\t\tcase 'j': /* non-standard */\n\t\t\tif (width === 0)\n\t\t\t\twidth = 10;\n\t\t\tret += mod_util.inspect(arg, false, width);\n\t\t\tbreak;\n\n\t\tcase 'r': /* non-standard */\n\t\t\tret += dumpException(arg);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow (new Error('unsupported conversion: ' +\n\t\t\t    conversion));\n\t\t}\n\t}\n\n\tret += fmt;\n\treturn (ret);\n}\n\nfunction jsPrintf() {\n\tvar args = Array.prototype.slice.call(arguments);\n\targs.unshift(process.stdout);\n\tjsFprintf.apply(null, args);\n}\n\nfunction jsFprintf(stream) {\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\treturn (stream.write(jsSprintf.apply(this, args)));\n}\n\nfunction doPad(chr, width, left, str)\n{\n\tvar ret = str;\n\n\twhile (ret.length < width) {\n\t\tif (left)\n\t\t\tret += chr;\n\t\telse\n\t\t\tret = chr + ret;\n\t}\n\n\treturn (ret);\n}\n\n/*\n * This function dumps long stack traces for exceptions having a cause() method.\n * See node-verror for an example.\n */\nfunction dumpException(ex)\n{\n\tvar ret;\n\n\tif (!(ex instanceof Error))\n\t\tthrow (new Error(jsSprintf('invalid type for %%r: %j', ex)));\n\n\t/* Note that V8 prepends \"ex.stack\" with ex.toString(). */\n\tret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;\n\n\tif (ex.cause && typeof (ex.cause) === 'function') {\n\t\tvar cex = ex.cause();\n\t\tif (cex) {\n\t\t\tret += '\\nCaused by: ' + dumpException(cex);\n\t\t}\n\t}\n\n\treturn (ret);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}