{"ast":null,"code":"// Copyright 2017 Joyent, Inc.\n\nmodule.exports = {\n  read: read,\n  verify: verify,\n  sign: sign,\n  signAsync: signAsync,\n  write: write,\n  /* Internal private API */\n  fromBuffer: fromBuffer,\n  toBuffer: toBuffer\n};\nvar assert = require('assert-plus');\nvar SSHBuffer = require('../ssh-buffer');\nvar crypto = require('crypto');\nvar Buffer = require('safer-buffer').Buffer;\nvar algs = require('../algs');\nvar Key = require('../key');\nvar PrivateKey = require('../private-key');\nvar Identity = require('../identity');\nvar rfc4253 = require('./rfc4253');\nvar Signature = require('../signature');\nvar utils = require('../utils');\nvar Certificate = require('../certificate');\nfunction verify(cert, key) {\n  /*\n   * We always give an issuerKey, so if our verify() is being called then\n   * there was no signature. Return false.\n   */\n  return false;\n}\nvar TYPES = {\n  'user': 1,\n  'host': 2\n};\nObject.keys(TYPES).forEach(function (k) {\n  TYPES[TYPES[k]] = k;\n});\nvar ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;\nfunction read(buf, options) {\n  if (Buffer.isBuffer(buf)) buf = buf.toString('ascii');\n  var parts = buf.trim().split(/[ \\t\\n]+/g);\n  if (parts.length < 2 || parts.length > 3) throw new Error('Not a valid SSH certificate line');\n  var algo = parts[0];\n  var data = parts[1];\n  data = Buffer.from(data, 'base64');\n  return fromBuffer(data, algo);\n}\nfunction fromBuffer(data, algo, partial) {\n  var sshbuf = new SSHBuffer({\n    buffer: data\n  });\n  var innerAlgo = sshbuf.readString();\n  if (algo !== undefined && innerAlgo !== algo) throw new Error('SSH certificate algorithm mismatch');\n  if (algo === undefined) algo = innerAlgo;\n  var cert = {};\n  cert.signatures = {};\n  cert.signatures.openssh = {};\n  cert.signatures.openssh.nonce = sshbuf.readBuffer();\n  var key = {};\n  var parts = key.parts = [];\n  key.type = getAlg(algo);\n  var partCount = algs.info[key.type].parts.length;\n  while (parts.length < partCount) parts.push(sshbuf.readPart());\n  assert.ok(parts.length >= 1, 'key must have at least one part');\n  var algInfo = algs.info[key.type];\n  if (key.type === 'ecdsa') {\n    var res = ECDSA_ALGO.exec(algo);\n    assert.ok(res !== null);\n    assert.strictEqual(res[1], parts[0].data.toString());\n  }\n  for (var i = 0; i < algInfo.parts.length; ++i) {\n    parts[i].name = algInfo.parts[i];\n    if (parts[i].name !== 'curve' && algInfo.normalize !== false) {\n      var p = parts[i];\n      p.data = utils.mpNormalize(p.data);\n    }\n  }\n  cert.subjectKey = new Key(key);\n  cert.serial = sshbuf.readInt64();\n  var type = TYPES[sshbuf.readInt()];\n  assert.string(type, 'valid cert type');\n  cert.signatures.openssh.keyId = sshbuf.readString();\n  var principals = [];\n  var pbuf = sshbuf.readBuffer();\n  var psshbuf = new SSHBuffer({\n    buffer: pbuf\n  });\n  while (!psshbuf.atEnd()) principals.push(psshbuf.readString());\n  if (principals.length === 0) principals = ['*'];\n  cert.subjects = principals.map(function (pr) {\n    if (type === 'user') return Identity.forUser(pr);else if (type === 'host') return Identity.forHost(pr);\n    throw new Error('Unknown identity type ' + type);\n  });\n  cert.validFrom = int64ToDate(sshbuf.readInt64());\n  cert.validUntil = int64ToDate(sshbuf.readInt64());\n  var exts = [];\n  var extbuf = new SSHBuffer({\n    buffer: sshbuf.readBuffer()\n  });\n  var ext;\n  while (!extbuf.atEnd()) {\n    ext = {\n      critical: true\n    };\n    ext.name = extbuf.readString();\n    ext.data = extbuf.readBuffer();\n    exts.push(ext);\n  }\n  extbuf = new SSHBuffer({\n    buffer: sshbuf.readBuffer()\n  });\n  while (!extbuf.atEnd()) {\n    ext = {\n      critical: false\n    };\n    ext.name = extbuf.readString();\n    ext.data = extbuf.readBuffer();\n    exts.push(ext);\n  }\n  cert.signatures.openssh.exts = exts;\n\n  /* reserved */\n  sshbuf.readBuffer();\n  var signingKeyBuf = sshbuf.readBuffer();\n  cert.issuerKey = rfc4253.read(signingKeyBuf);\n\n  /*\n   * OpenSSH certs don't give the identity of the issuer, just their\n   * public key. So, we use an Identity that matches anything. The\n   * isSignedBy() function will later tell you if the key matches.\n   */\n  cert.issuer = Identity.forHost('**');\n  var sigBuf = sshbuf.readBuffer();\n  cert.signatures.openssh.signature = Signature.parse(sigBuf, cert.issuerKey.type, 'ssh');\n  if (partial !== undefined) {\n    partial.remainder = sshbuf.remainder();\n    partial.consumed = sshbuf._offset;\n  }\n  return new Certificate(cert);\n}\nfunction int64ToDate(buf) {\n  var i = buf.readUInt32BE(0) * 4294967296;\n  i += buf.readUInt32BE(4);\n  var d = new Date();\n  d.setTime(i * 1000);\n  d.sourceInt64 = buf;\n  return d;\n}\nfunction dateToInt64(date) {\n  if (date.sourceInt64 !== undefined) return date.sourceInt64;\n  var i = Math.round(date.getTime() / 1000);\n  var upper = Math.floor(i / 4294967296);\n  var lower = Math.floor(i % 4294967296);\n  var buf = Buffer.alloc(8);\n  buf.writeUInt32BE(upper, 0);\n  buf.writeUInt32BE(lower, 4);\n  return buf;\n}\nfunction sign(cert, key) {\n  if (cert.signatures.openssh === undefined) cert.signatures.openssh = {};\n  try {\n    var blob = toBuffer(cert, true);\n  } catch (e) {\n    delete cert.signatures.openssh;\n    return false;\n  }\n  var sig = cert.signatures.openssh;\n  var hashAlgo = undefined;\n  if (key.type === 'rsa' || key.type === 'dsa') hashAlgo = 'sha1';\n  var signer = key.createSign(hashAlgo);\n  signer.write(blob);\n  sig.signature = signer.sign();\n  return true;\n}\nfunction signAsync(cert, signer, done) {\n  if (cert.signatures.openssh === undefined) cert.signatures.openssh = {};\n  try {\n    var blob = toBuffer(cert, true);\n  } catch (e) {\n    delete cert.signatures.openssh;\n    done(e);\n    return;\n  }\n  var sig = cert.signatures.openssh;\n  signer(blob, function (err, signature) {\n    if (err) {\n      done(err);\n      return;\n    }\n    try {\n      /*\n       * This will throw if the signature isn't of a\n       * type/algo that can be used for SSH.\n       */\n      signature.toBuffer('ssh');\n    } catch (e) {\n      done(e);\n      return;\n    }\n    sig.signature = signature;\n    done();\n  });\n}\nfunction write(cert, options) {\n  if (options === undefined) options = {};\n  var blob = toBuffer(cert);\n  var out = getCertType(cert.subjectKey) + ' ' + blob.toString('base64');\n  if (options.comment) out = out + ' ' + options.comment;\n  return out;\n}\nfunction toBuffer(cert, noSig) {\n  assert.object(cert.signatures.openssh, 'signature for openssh format');\n  var sig = cert.signatures.openssh;\n  if (sig.nonce === undefined) sig.nonce = crypto.randomBytes(16);\n  var buf = new SSHBuffer({});\n  buf.writeString(getCertType(cert.subjectKey));\n  buf.writeBuffer(sig.nonce);\n  var key = cert.subjectKey;\n  var algInfo = algs.info[key.type];\n  algInfo.parts.forEach(function (part) {\n    buf.writePart(key.part[part]);\n  });\n  buf.writeInt64(cert.serial);\n  var type = cert.subjects[0].type;\n  assert.notStrictEqual(type, 'unknown');\n  cert.subjects.forEach(function (id) {\n    assert.strictEqual(id.type, type);\n  });\n  type = TYPES[type];\n  buf.writeInt(type);\n  if (sig.keyId === undefined) {\n    sig.keyId = cert.subjects[0].type + '_' + (cert.subjects[0].uid || cert.subjects[0].hostname);\n  }\n  buf.writeString(sig.keyId);\n  var sub = new SSHBuffer({});\n  cert.subjects.forEach(function (id) {\n    if (type === TYPES.host) sub.writeString(id.hostname);else if (type === TYPES.user) sub.writeString(id.uid);\n  });\n  buf.writeBuffer(sub.toBuffer());\n  buf.writeInt64(dateToInt64(cert.validFrom));\n  buf.writeInt64(dateToInt64(cert.validUntil));\n  var exts = sig.exts;\n  if (exts === undefined) exts = [];\n  var extbuf = new SSHBuffer({});\n  exts.forEach(function (ext) {\n    if (ext.critical !== true) return;\n    extbuf.writeString(ext.name);\n    extbuf.writeBuffer(ext.data);\n  });\n  buf.writeBuffer(extbuf.toBuffer());\n  extbuf = new SSHBuffer({});\n  exts.forEach(function (ext) {\n    if (ext.critical === true) return;\n    extbuf.writeString(ext.name);\n    extbuf.writeBuffer(ext.data);\n  });\n  buf.writeBuffer(extbuf.toBuffer());\n\n  /* reserved */\n  buf.writeBuffer(Buffer.alloc(0));\n  sub = rfc4253.write(cert.issuerKey);\n  buf.writeBuffer(sub);\n  if (!noSig) buf.writeBuffer(sig.signature.toBuffer('ssh'));\n  return buf.toBuffer();\n}\nfunction getAlg(certType) {\n  if (certType === 'ssh-rsa-cert-v01@openssh.com') return 'rsa';\n  if (certType === 'ssh-dss-cert-v01@openssh.com') return 'dsa';\n  if (certType.match(ECDSA_ALGO)) return 'ecdsa';\n  if (certType === 'ssh-ed25519-cert-v01@openssh.com') return 'ed25519';\n  throw new Error('Unsupported cert type ' + certType);\n}\nfunction getCertType(key) {\n  if (key.type === 'rsa') return 'ssh-rsa-cert-v01@openssh.com';\n  if (key.type === 'dsa') return 'ssh-dss-cert-v01@openssh.com';\n  if (key.type === 'ecdsa') return 'ecdsa-sha2-' + key.curve + '-cert-v01@openssh.com';\n  if (key.type === 'ed25519') return 'ssh-ed25519-cert-v01@openssh.com';\n  throw new Error('Unsupported key type ' + key.type);\n}","map":{"version":3,"names":["module","exports","read","verify","sign","signAsync","write","fromBuffer","toBuffer","assert","require","SSHBuffer","crypto","Buffer","algs","Key","PrivateKey","Identity","rfc4253","Signature","utils","Certificate","cert","key","TYPES","Object","keys","forEach","k","ECDSA_ALGO","buf","options","isBuffer","toString","parts","trim","split","length","Error","algo","data","from","partial","sshbuf","buffer","innerAlgo","readString","undefined","signatures","openssh","nonce","readBuffer","type","getAlg","partCount","info","push","readPart","ok","algInfo","res","exec","strictEqual","i","name","normalize","p","mpNormalize","subjectKey","serial","readInt64","readInt","string","keyId","principals","pbuf","psshbuf","atEnd","subjects","map","pr","forUser","forHost","validFrom","int64ToDate","validUntil","exts","extbuf","ext","critical","signingKeyBuf","issuerKey","issuer","sigBuf","signature","parse","remainder","consumed","_offset","readUInt32BE","d","Date","setTime","sourceInt64","dateToInt64","date","Math","round","getTime","upper","floor","lower","alloc","writeUInt32BE","blob","e","sig","hashAlgo","signer","createSign","done","err","out","getCertType","comment","noSig","object","randomBytes","writeString","writeBuffer","part","writePart","writeInt64","notStrictEqual","id","writeInt","uid","hostname","sub","host","user","certType","match","curve"],"sources":["/Users/mohitgupta/Downloads/orgs/Clone/inst/node_modules/sshpk/lib/formats/openssh-cert.js"],"sourcesContent":["// Copyright 2017 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\tverify: verify,\n\tsign: sign,\n\tsignAsync: signAsync,\n\twrite: write,\n\n\t/* Internal private API */\n\tfromBuffer: fromBuffer,\n\ttoBuffer: toBuffer\n};\n\nvar assert = require('assert-plus');\nvar SSHBuffer = require('../ssh-buffer');\nvar crypto = require('crypto');\nvar Buffer = require('safer-buffer').Buffer;\nvar algs = require('../algs');\nvar Key = require('../key');\nvar PrivateKey = require('../private-key');\nvar Identity = require('../identity');\nvar rfc4253 = require('./rfc4253');\nvar Signature = require('../signature');\nvar utils = require('../utils');\nvar Certificate = require('../certificate');\n\nfunction verify(cert, key) {\n\t/*\n\t * We always give an issuerKey, so if our verify() is being called then\n\t * there was no signature. Return false.\n\t */\n\treturn (false);\n}\n\nvar TYPES = {\n\t'user': 1,\n\t'host': 2\n};\nObject.keys(TYPES).forEach(function (k) { TYPES[TYPES[k]] = k; });\n\nvar ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;\n\nfunction read(buf, options) {\n\tif (Buffer.isBuffer(buf))\n\t\tbuf = buf.toString('ascii');\n\tvar parts = buf.trim().split(/[ \\t\\n]+/g);\n\tif (parts.length < 2 || parts.length > 3)\n\t\tthrow (new Error('Not a valid SSH certificate line'));\n\n\tvar algo = parts[0];\n\tvar data = parts[1];\n\n\tdata = Buffer.from(data, 'base64');\n\treturn (fromBuffer(data, algo));\n}\n\nfunction fromBuffer(data, algo, partial) {\n\tvar sshbuf = new SSHBuffer({ buffer: data });\n\tvar innerAlgo = sshbuf.readString();\n\tif (algo !== undefined && innerAlgo !== algo)\n\t\tthrow (new Error('SSH certificate algorithm mismatch'));\n\tif (algo === undefined)\n\t\talgo = innerAlgo;\n\n\tvar cert = {};\n\tcert.signatures = {};\n\tcert.signatures.openssh = {};\n\n\tcert.signatures.openssh.nonce = sshbuf.readBuffer();\n\n\tvar key = {};\n\tvar parts = (key.parts = []);\n\tkey.type = getAlg(algo);\n\n\tvar partCount = algs.info[key.type].parts.length;\n\twhile (parts.length < partCount)\n\t\tparts.push(sshbuf.readPart());\n\tassert.ok(parts.length >= 1, 'key must have at least one part');\n\n\tvar algInfo = algs.info[key.type];\n\tif (key.type === 'ecdsa') {\n\t\tvar res = ECDSA_ALGO.exec(algo);\n\t\tassert.ok(res !== null);\n\t\tassert.strictEqual(res[1], parts[0].data.toString());\n\t}\n\n\tfor (var i = 0; i < algInfo.parts.length; ++i) {\n\t\tparts[i].name = algInfo.parts[i];\n\t\tif (parts[i].name !== 'curve' &&\n\t\t    algInfo.normalize !== false) {\n\t\t\tvar p = parts[i];\n\t\t\tp.data = utils.mpNormalize(p.data);\n\t\t}\n\t}\n\n\tcert.subjectKey = new Key(key);\n\n\tcert.serial = sshbuf.readInt64();\n\n\tvar type = TYPES[sshbuf.readInt()];\n\tassert.string(type, 'valid cert type');\n\n\tcert.signatures.openssh.keyId = sshbuf.readString();\n\n\tvar principals = [];\n\tvar pbuf = sshbuf.readBuffer();\n\tvar psshbuf = new SSHBuffer({ buffer: pbuf });\n\twhile (!psshbuf.atEnd())\n\t\tprincipals.push(psshbuf.readString());\n\tif (principals.length === 0)\n\t\tprincipals = ['*'];\n\n\tcert.subjects = principals.map(function (pr) {\n\t\tif (type === 'user')\n\t\t\treturn (Identity.forUser(pr));\n\t\telse if (type === 'host')\n\t\t\treturn (Identity.forHost(pr));\n\t\tthrow (new Error('Unknown identity type ' + type));\n\t});\n\n\tcert.validFrom = int64ToDate(sshbuf.readInt64());\n\tcert.validUntil = int64ToDate(sshbuf.readInt64());\n\n\tvar exts = [];\n\tvar extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });\n\tvar ext;\n\twhile (!extbuf.atEnd()) {\n\t\text = { critical: true };\n\t\text.name = extbuf.readString();\n\t\text.data = extbuf.readBuffer();\n\t\texts.push(ext);\n\t}\n\textbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });\n\twhile (!extbuf.atEnd()) {\n\t\text = { critical: false };\n\t\text.name = extbuf.readString();\n\t\text.data = extbuf.readBuffer();\n\t\texts.push(ext);\n\t}\n\tcert.signatures.openssh.exts = exts;\n\n\t/* reserved */\n\tsshbuf.readBuffer();\n\n\tvar signingKeyBuf = sshbuf.readBuffer();\n\tcert.issuerKey = rfc4253.read(signingKeyBuf);\n\n\t/*\n\t * OpenSSH certs don't give the identity of the issuer, just their\n\t * public key. So, we use an Identity that matches anything. The\n\t * isSignedBy() function will later tell you if the key matches.\n\t */\n\tcert.issuer = Identity.forHost('**');\n\n\tvar sigBuf = sshbuf.readBuffer();\n\tcert.signatures.openssh.signature =\n\t    Signature.parse(sigBuf, cert.issuerKey.type, 'ssh');\n\n\tif (partial !== undefined) {\n\t\tpartial.remainder = sshbuf.remainder();\n\t\tpartial.consumed = sshbuf._offset;\n\t}\n\n\treturn (new Certificate(cert));\n}\n\nfunction int64ToDate(buf) {\n\tvar i = buf.readUInt32BE(0) * 4294967296;\n\ti += buf.readUInt32BE(4);\n\tvar d = new Date();\n\td.setTime(i * 1000);\n\td.sourceInt64 = buf;\n\treturn (d);\n}\n\nfunction dateToInt64(date) {\n\tif (date.sourceInt64 !== undefined)\n\t\treturn (date.sourceInt64);\n\tvar i = Math.round(date.getTime() / 1000);\n\tvar upper = Math.floor(i / 4294967296);\n\tvar lower = Math.floor(i % 4294967296);\n\tvar buf = Buffer.alloc(8);\n\tbuf.writeUInt32BE(upper, 0);\n\tbuf.writeUInt32BE(lower, 4);\n\treturn (buf);\n}\n\nfunction sign(cert, key) {\n\tif (cert.signatures.openssh === undefined)\n\t\tcert.signatures.openssh = {};\n\ttry {\n\t\tvar blob = toBuffer(cert, true);\n\t} catch (e) {\n\t\tdelete (cert.signatures.openssh);\n\t\treturn (false);\n\t}\n\tvar sig = cert.signatures.openssh;\n\tvar hashAlgo = undefined;\n\tif (key.type === 'rsa' || key.type === 'dsa')\n\t\thashAlgo = 'sha1';\n\tvar signer = key.createSign(hashAlgo);\n\tsigner.write(blob);\n\tsig.signature = signer.sign();\n\treturn (true);\n}\n\nfunction signAsync(cert, signer, done) {\n\tif (cert.signatures.openssh === undefined)\n\t\tcert.signatures.openssh = {};\n\ttry {\n\t\tvar blob = toBuffer(cert, true);\n\t} catch (e) {\n\t\tdelete (cert.signatures.openssh);\n\t\tdone(e);\n\t\treturn;\n\t}\n\tvar sig = cert.signatures.openssh;\n\n\tsigner(blob, function (err, signature) {\n\t\tif (err) {\n\t\t\tdone(err);\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\t/*\n\t\t\t * This will throw if the signature isn't of a\n\t\t\t * type/algo that can be used for SSH.\n\t\t\t */\n\t\t\tsignature.toBuffer('ssh');\n\t\t} catch (e) {\n\t\t\tdone(e);\n\t\t\treturn;\n\t\t}\n\t\tsig.signature = signature;\n\t\tdone();\n\t});\n}\n\nfunction write(cert, options) {\n\tif (options === undefined)\n\t\toptions = {};\n\n\tvar blob = toBuffer(cert);\n\tvar out = getCertType(cert.subjectKey) + ' ' + blob.toString('base64');\n\tif (options.comment)\n\t\tout = out + ' ' + options.comment;\n\treturn (out);\n}\n\n\nfunction toBuffer(cert, noSig) {\n\tassert.object(cert.signatures.openssh, 'signature for openssh format');\n\tvar sig = cert.signatures.openssh;\n\n\tif (sig.nonce === undefined)\n\t\tsig.nonce = crypto.randomBytes(16);\n\tvar buf = new SSHBuffer({});\n\tbuf.writeString(getCertType(cert.subjectKey));\n\tbuf.writeBuffer(sig.nonce);\n\n\tvar key = cert.subjectKey;\n\tvar algInfo = algs.info[key.type];\n\talgInfo.parts.forEach(function (part) {\n\t\tbuf.writePart(key.part[part]);\n\t});\n\n\tbuf.writeInt64(cert.serial);\n\n\tvar type = cert.subjects[0].type;\n\tassert.notStrictEqual(type, 'unknown');\n\tcert.subjects.forEach(function (id) {\n\t\tassert.strictEqual(id.type, type);\n\t});\n\ttype = TYPES[type];\n\tbuf.writeInt(type);\n\n\tif (sig.keyId === undefined) {\n\t\tsig.keyId = cert.subjects[0].type + '_' +\n\t\t    (cert.subjects[0].uid || cert.subjects[0].hostname);\n\t}\n\tbuf.writeString(sig.keyId);\n\n\tvar sub = new SSHBuffer({});\n\tcert.subjects.forEach(function (id) {\n\t\tif (type === TYPES.host)\n\t\t\tsub.writeString(id.hostname);\n\t\telse if (type === TYPES.user)\n\t\t\tsub.writeString(id.uid);\n\t});\n\tbuf.writeBuffer(sub.toBuffer());\n\n\tbuf.writeInt64(dateToInt64(cert.validFrom));\n\tbuf.writeInt64(dateToInt64(cert.validUntil));\n\n\tvar exts = sig.exts;\n\tif (exts === undefined)\n\t\texts = [];\n\n\tvar extbuf = new SSHBuffer({});\n\texts.forEach(function (ext) {\n\t\tif (ext.critical !== true)\n\t\t\treturn;\n\t\textbuf.writeString(ext.name);\n\t\textbuf.writeBuffer(ext.data);\n\t});\n\tbuf.writeBuffer(extbuf.toBuffer());\n\n\textbuf = new SSHBuffer({});\n\texts.forEach(function (ext) {\n\t\tif (ext.critical === true)\n\t\t\treturn;\n\t\textbuf.writeString(ext.name);\n\t\textbuf.writeBuffer(ext.data);\n\t});\n\tbuf.writeBuffer(extbuf.toBuffer());\n\n\t/* reserved */\n\tbuf.writeBuffer(Buffer.alloc(0));\n\n\tsub = rfc4253.write(cert.issuerKey);\n\tbuf.writeBuffer(sub);\n\n\tif (!noSig)\n\t\tbuf.writeBuffer(sig.signature.toBuffer('ssh'));\n\n\treturn (buf.toBuffer());\n}\n\nfunction getAlg(certType) {\n\tif (certType === 'ssh-rsa-cert-v01@openssh.com')\n\t\treturn ('rsa');\n\tif (certType === 'ssh-dss-cert-v01@openssh.com')\n\t\treturn ('dsa');\n\tif (certType.match(ECDSA_ALGO))\n\t\treturn ('ecdsa');\n\tif (certType === 'ssh-ed25519-cert-v01@openssh.com')\n\t\treturn ('ed25519');\n\tthrow (new Error('Unsupported cert type ' + certType));\n}\n\nfunction getCertType(key) {\n\tif (key.type === 'rsa')\n\t\treturn ('ssh-rsa-cert-v01@openssh.com');\n\tif (key.type === 'dsa')\n\t\treturn ('ssh-dss-cert-v01@openssh.com');\n\tif (key.type === 'ecdsa')\n\t\treturn ('ecdsa-sha2-' + key.curve + '-cert-v01@openssh.com');\n\tif (key.type === 'ed25519')\n\t\treturn ('ssh-ed25519-cert-v01@openssh.com');\n\tthrow (new Error('Unsupported key type ' + key.type));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}