{"ast":null,"code":"// Copyright 2017 Joyent, Inc.\n\nmodule.exports = {\n  read: read,\n  write: write\n};\nvar assert = require('assert-plus');\nvar Buffer = require('safer-buffer').Buffer;\nvar Key = require('../key');\nvar PrivateKey = require('../private-key');\nvar utils = require('../utils');\nvar SSHBuffer = require('../ssh-buffer');\nvar Dhe = require('../dhe');\nvar supportedAlgos = {\n  'rsa-sha1': 5,\n  'rsa-sha256': 8,\n  'rsa-sha512': 10,\n  'ecdsa-p256-sha256': 13,\n  'ecdsa-p384-sha384': 14\n  /*\n   * ed25519 is hypothetically supported with id 15\n   * but the common tools available don't appear to be\n   * capable of generating/using ed25519 keys\n   */\n};\n\nvar supportedAlgosById = {};\nObject.keys(supportedAlgos).forEach(function (k) {\n  supportedAlgosById[supportedAlgos[k]] = k.toUpperCase();\n});\nfunction read(buf, options) {\n  if (typeof buf !== 'string') {\n    assert.buffer(buf, 'buf');\n    buf = buf.toString('ascii');\n  }\n  var lines = buf.split('\\n');\n  if (lines[0].match(/^Private-key-format\\: v1/)) {\n    var algElems = lines[1].split(' ');\n    var algoNum = parseInt(algElems[1], 10);\n    var algoName = algElems[2];\n    if (!supportedAlgosById[algoNum]) throw new Error('Unsupported algorithm: ' + algoName);\n    return readDNSSECPrivateKey(algoNum, lines.slice(2));\n  }\n\n  // skip any comment-lines\n  var line = 0;\n  /* JSSTYLED */\n  while (lines[line].match(/^\\;/)) line++;\n  // we should now have *one single* line left with our KEY on it.\n  if ((lines[line].match(/\\. IN KEY /) || lines[line].match(/\\. IN DNSKEY /)) && lines[line + 1].length === 0) {\n    return readRFC3110(lines[line]);\n  }\n  throw new Error('Cannot parse dnssec key');\n}\nfunction readRFC3110(keyString) {\n  var elems = keyString.split(' ');\n  //unused var flags = parseInt(elems[3], 10);\n  //unused var protocol = parseInt(elems[4], 10);\n  var algorithm = parseInt(elems[5], 10);\n  if (!supportedAlgosById[algorithm]) throw new Error('Unsupported algorithm: ' + algorithm);\n  var base64key = elems.slice(6, elems.length).join();\n  var keyBuffer = Buffer.from(base64key, 'base64');\n  if (supportedAlgosById[algorithm].match(/^RSA-/)) {\n    // join the rest of the body into a single base64-blob\n    var publicExponentLen = keyBuffer.readUInt8(0);\n    if (publicExponentLen != 3 && publicExponentLen != 1) throw new Error('Cannot parse dnssec key: ' + 'unsupported exponent length');\n    var publicExponent = keyBuffer.slice(1, publicExponentLen + 1);\n    publicExponent = utils.mpNormalize(publicExponent);\n    var modulus = keyBuffer.slice(1 + publicExponentLen);\n    modulus = utils.mpNormalize(modulus);\n    // now, make the key\n    var rsaKey = {\n      type: 'rsa',\n      parts: []\n    };\n    rsaKey.parts.push({\n      name: 'e',\n      data: publicExponent\n    });\n    rsaKey.parts.push({\n      name: 'n',\n      data: modulus\n    });\n    return new Key(rsaKey);\n  }\n  if (supportedAlgosById[algorithm] === 'ECDSA-P384-SHA384' || supportedAlgosById[algorithm] === 'ECDSA-P256-SHA256') {\n    var curve = 'nistp384';\n    var size = 384;\n    if (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {\n      curve = 'nistp256';\n      size = 256;\n    }\n    var ecdsaKey = {\n      type: 'ecdsa',\n      curve: curve,\n      size: size,\n      parts: [{\n        name: 'curve',\n        data: Buffer.from(curve)\n      }, {\n        name: 'Q',\n        data: utils.ecNormalize(keyBuffer)\n      }]\n    };\n    return new Key(ecdsaKey);\n  }\n  throw new Error('Unsupported algorithm: ' + supportedAlgosById[algorithm]);\n}\nfunction elementToBuf(e) {\n  return Buffer.from(e.split(' ')[1], 'base64');\n}\nfunction readDNSSECRSAPrivateKey(elements) {\n  var rsaParams = {};\n  elements.forEach(function (element) {\n    if (element.split(' ')[0] === 'Modulus:') rsaParams['n'] = elementToBuf(element);else if (element.split(' ')[0] === 'PublicExponent:') rsaParams['e'] = elementToBuf(element);else if (element.split(' ')[0] === 'PrivateExponent:') rsaParams['d'] = elementToBuf(element);else if (element.split(' ')[0] === 'Prime1:') rsaParams['p'] = elementToBuf(element);else if (element.split(' ')[0] === 'Prime2:') rsaParams['q'] = elementToBuf(element);else if (element.split(' ')[0] === 'Exponent1:') rsaParams['dmodp'] = elementToBuf(element);else if (element.split(' ')[0] === 'Exponent2:') rsaParams['dmodq'] = elementToBuf(element);else if (element.split(' ')[0] === 'Coefficient:') rsaParams['iqmp'] = elementToBuf(element);\n  });\n  // now, make the key\n  var key = {\n    type: 'rsa',\n    parts: [{\n      name: 'e',\n      data: utils.mpNormalize(rsaParams['e'])\n    }, {\n      name: 'n',\n      data: utils.mpNormalize(rsaParams['n'])\n    }, {\n      name: 'd',\n      data: utils.mpNormalize(rsaParams['d'])\n    }, {\n      name: 'p',\n      data: utils.mpNormalize(rsaParams['p'])\n    }, {\n      name: 'q',\n      data: utils.mpNormalize(rsaParams['q'])\n    }, {\n      name: 'dmodp',\n      data: utils.mpNormalize(rsaParams['dmodp'])\n    }, {\n      name: 'dmodq',\n      data: utils.mpNormalize(rsaParams['dmodq'])\n    }, {\n      name: 'iqmp',\n      data: utils.mpNormalize(rsaParams['iqmp'])\n    }]\n  };\n  return new PrivateKey(key);\n}\nfunction readDNSSECPrivateKey(alg, elements) {\n  if (supportedAlgosById[alg].match(/^RSA-/)) {\n    return readDNSSECRSAPrivateKey(elements);\n  }\n  if (supportedAlgosById[alg] === 'ECDSA-P384-SHA384' || supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {\n    var d = Buffer.from(elements[0].split(' ')[1], 'base64');\n    var curve = 'nistp384';\n    var size = 384;\n    if (supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {\n      curve = 'nistp256';\n      size = 256;\n    }\n    // DNSSEC generates the public-key on the fly (go calculate it)\n    var publicKey = utils.publicFromPrivateECDSA(curve, d);\n    var Q = publicKey.part['Q'].data;\n    var ecdsaKey = {\n      type: 'ecdsa',\n      curve: curve,\n      size: size,\n      parts: [{\n        name: 'curve',\n        data: Buffer.from(curve)\n      }, {\n        name: 'd',\n        data: d\n      }, {\n        name: 'Q',\n        data: Q\n      }]\n    };\n    return new PrivateKey(ecdsaKey);\n  }\n  throw new Error('Unsupported algorithm: ' + supportedAlgosById[alg]);\n}\nfunction dnssecTimestamp(date) {\n  var year = date.getFullYear() + ''; //stringify\n  var month = date.getMonth() + 1;\n  var timestampStr = year + month + date.getUTCDate();\n  timestampStr += '' + date.getUTCHours() + date.getUTCMinutes();\n  timestampStr += date.getUTCSeconds();\n  return timestampStr;\n}\nfunction rsaAlgFromOptions(opts) {\n  if (!opts || !opts.hashAlgo || opts.hashAlgo === 'sha1') return '5 (RSASHA1)';else if (opts.hashAlgo === 'sha256') return '8 (RSASHA256)';else if (opts.hashAlgo === 'sha512') return '10 (RSASHA512)';else throw new Error('Unknown or unsupported hash: ' + opts.hashAlgo);\n}\nfunction writeRSA(key, options) {\n  // if we're missing parts, add them.\n  if (!key.part.dmodp || !key.part.dmodq) {\n    utils.addRSAMissing(key);\n  }\n  var out = '';\n  out += 'Private-key-format: v1.3\\n';\n  out += 'Algorithm: ' + rsaAlgFromOptions(options) + '\\n';\n  var n = utils.mpDenormalize(key.part['n'].data);\n  out += 'Modulus: ' + n.toString('base64') + '\\n';\n  var e = utils.mpDenormalize(key.part['e'].data);\n  out += 'PublicExponent: ' + e.toString('base64') + '\\n';\n  var d = utils.mpDenormalize(key.part['d'].data);\n  out += 'PrivateExponent: ' + d.toString('base64') + '\\n';\n  var p = utils.mpDenormalize(key.part['p'].data);\n  out += 'Prime1: ' + p.toString('base64') + '\\n';\n  var q = utils.mpDenormalize(key.part['q'].data);\n  out += 'Prime2: ' + q.toString('base64') + '\\n';\n  var dmodp = utils.mpDenormalize(key.part['dmodp'].data);\n  out += 'Exponent1: ' + dmodp.toString('base64') + '\\n';\n  var dmodq = utils.mpDenormalize(key.part['dmodq'].data);\n  out += 'Exponent2: ' + dmodq.toString('base64') + '\\n';\n  var iqmp = utils.mpDenormalize(key.part['iqmp'].data);\n  out += 'Coefficient: ' + iqmp.toString('base64') + '\\n';\n  // Assume that we're valid as-of now\n  var timestamp = new Date();\n  out += 'Created: ' + dnssecTimestamp(timestamp) + '\\n';\n  out += 'Publish: ' + dnssecTimestamp(timestamp) + '\\n';\n  out += 'Activate: ' + dnssecTimestamp(timestamp) + '\\n';\n  return Buffer.from(out, 'ascii');\n}\nfunction writeECDSA(key, options) {\n  var out = '';\n  out += 'Private-key-format: v1.3\\n';\n  if (key.curve === 'nistp256') {\n    out += 'Algorithm: 13 (ECDSAP256SHA256)\\n';\n  } else if (key.curve === 'nistp384') {\n    out += 'Algorithm: 14 (ECDSAP384SHA384)\\n';\n  } else {\n    throw new Error('Unsupported curve');\n  }\n  var base64Key = key.part['d'].data.toString('base64');\n  out += 'PrivateKey: ' + base64Key + '\\n';\n\n  // Assume that we're valid as-of now\n  var timestamp = new Date();\n  out += 'Created: ' + dnssecTimestamp(timestamp) + '\\n';\n  out += 'Publish: ' + dnssecTimestamp(timestamp) + '\\n';\n  out += 'Activate: ' + dnssecTimestamp(timestamp) + '\\n';\n  return Buffer.from(out, 'ascii');\n}\nfunction write(key, options) {\n  if (PrivateKey.isPrivateKey(key)) {\n    if (key.type === 'rsa') {\n      return writeRSA(key, options);\n    } else if (key.type === 'ecdsa') {\n      return writeECDSA(key, options);\n    } else {\n      throw new Error('Unsupported algorithm: ' + key.type);\n    }\n  } else if (Key.isKey(key)) {\n    /*\n     * RFC3110 requires a keyname, and a keytype, which we\n     * don't really have a mechanism for specifying such\n     * additional metadata.\n     */\n    throw new Error('Format \"dnssec\" only supports ' + 'writing private keys');\n  } else {\n    throw new Error('key is not a Key or PrivateKey');\n  }\n}","map":{"version":3,"names":["module","exports","read","write","assert","require","Buffer","Key","PrivateKey","utils","SSHBuffer","Dhe","supportedAlgos","supportedAlgosById","Object","keys","forEach","k","toUpperCase","buf","options","buffer","toString","lines","split","match","algElems","algoNum","parseInt","algoName","Error","readDNSSECPrivateKey","slice","line","length","readRFC3110","keyString","elems","algorithm","base64key","join","keyBuffer","from","publicExponentLen","readUInt8","publicExponent","mpNormalize","modulus","rsaKey","type","parts","push","name","data","curve","size","ecdsaKey","ecNormalize","elementToBuf","e","readDNSSECRSAPrivateKey","elements","rsaParams","element","key","alg","d","publicKey","publicFromPrivateECDSA","Q","part","dnssecTimestamp","date","year","getFullYear","month","getMonth","timestampStr","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","rsaAlgFromOptions","opts","hashAlgo","writeRSA","dmodp","dmodq","addRSAMissing","out","n","mpDenormalize","p","q","iqmp","timestamp","Date","writeECDSA","base64Key","isPrivateKey","isKey"],"sources":["/Users/mohitgupta/Downloads/orgs/Clone/inst/node_modules/sshpk/lib/formats/dnssec.js"],"sourcesContent":["// Copyright 2017 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\twrite: write\n};\n\nvar assert = require('assert-plus');\nvar Buffer = require('safer-buffer').Buffer;\nvar Key = require('../key');\nvar PrivateKey = require('../private-key');\nvar utils = require('../utils');\nvar SSHBuffer = require('../ssh-buffer');\nvar Dhe = require('../dhe');\n\nvar supportedAlgos = {\n\t'rsa-sha1' : 5,\n\t'rsa-sha256' : 8,\n\t'rsa-sha512' : 10,\n\t'ecdsa-p256-sha256' : 13,\n\t'ecdsa-p384-sha384' : 14\n\t/*\n\t * ed25519 is hypothetically supported with id 15\n\t * but the common tools available don't appear to be\n\t * capable of generating/using ed25519 keys\n\t */\n};\n\nvar supportedAlgosById = {};\nObject.keys(supportedAlgos).forEach(function (k) {\n\tsupportedAlgosById[supportedAlgos[k]] = k.toUpperCase();\n});\n\nfunction read(buf, options) {\n\tif (typeof (buf) !== 'string') {\n\t\tassert.buffer(buf, 'buf');\n\t\tbuf = buf.toString('ascii');\n\t}\n\tvar lines = buf.split('\\n');\n\tif (lines[0].match(/^Private-key-format\\: v1/)) {\n\t\tvar algElems = lines[1].split(' ');\n\t\tvar algoNum = parseInt(algElems[1], 10);\n\t\tvar algoName = algElems[2];\n\t\tif (!supportedAlgosById[algoNum])\n\t\t\tthrow (new Error('Unsupported algorithm: ' + algoName));\n\t\treturn (readDNSSECPrivateKey(algoNum, lines.slice(2)));\n\t}\n\n\t// skip any comment-lines\n\tvar line = 0;\n\t/* JSSTYLED */\n\twhile (lines[line].match(/^\\;/))\n\t\tline++;\n\t// we should now have *one single* line left with our KEY on it.\n\tif ((lines[line].match(/\\. IN KEY /) ||\n\t    lines[line].match(/\\. IN DNSKEY /)) && lines[line+1].length === 0) {\n\t\treturn (readRFC3110(lines[line]));\n\t}\n\tthrow (new Error('Cannot parse dnssec key'));\n}\n\nfunction readRFC3110(keyString) {\n\tvar elems = keyString.split(' ');\n\t//unused var flags = parseInt(elems[3], 10);\n\t//unused var protocol = parseInt(elems[4], 10);\n\tvar algorithm = parseInt(elems[5], 10);\n\tif (!supportedAlgosById[algorithm])\n\t\tthrow (new Error('Unsupported algorithm: ' + algorithm));\n\tvar base64key = elems.slice(6, elems.length).join();\n\tvar keyBuffer = Buffer.from(base64key, 'base64');\n\tif (supportedAlgosById[algorithm].match(/^RSA-/)) {\n\t\t// join the rest of the body into a single base64-blob\n\t\tvar publicExponentLen = keyBuffer.readUInt8(0);\n\t\tif (publicExponentLen != 3 && publicExponentLen != 1)\n\t\t\tthrow (new Error('Cannot parse dnssec key: ' +\n\t\t\t    'unsupported exponent length'));\n\n\t\tvar publicExponent = keyBuffer.slice(1, publicExponentLen+1);\n\t\tpublicExponent = utils.mpNormalize(publicExponent);\n\t\tvar modulus = keyBuffer.slice(1+publicExponentLen);\n\t\tmodulus = utils.mpNormalize(modulus);\n\t\t// now, make the key\n\t\tvar rsaKey = {\n\t\t\ttype: 'rsa',\n\t\t\tparts: []\n\t\t};\n\t\trsaKey.parts.push({ name: 'e', data: publicExponent});\n\t\trsaKey.parts.push({ name: 'n', data: modulus});\n\t\treturn (new Key(rsaKey));\n\t}\n\tif (supportedAlgosById[algorithm] === 'ECDSA-P384-SHA384' ||\n\t    supportedAlgosById[algorithm] === 'ECDSA-P256-SHA256') {\n\t\tvar curve = 'nistp384';\n\t\tvar size = 384;\n\t\tif (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {\n\t\t\tcurve = 'nistp256';\n\t\t\tsize = 256;\n\t\t}\n\n\t\tvar ecdsaKey = {\n\t\t\ttype: 'ecdsa',\n\t\t\tcurve: curve,\n\t\t\tsize: size,\n\t\t\tparts: [\n\t\t\t\t{name: 'curve', data: Buffer.from(curve) },\n\t\t\t\t{name: 'Q', data: utils.ecNormalize(keyBuffer) }\n\t\t\t]\n\t\t};\n\t\treturn (new Key(ecdsaKey));\n\t}\n\tthrow (new Error('Unsupported algorithm: ' +\n\t    supportedAlgosById[algorithm]));\n}\n\nfunction elementToBuf(e) {\n\treturn (Buffer.from(e.split(' ')[1], 'base64'));\n}\n\nfunction readDNSSECRSAPrivateKey(elements) {\n\tvar rsaParams = {};\n\telements.forEach(function (element) {\n\t\tif (element.split(' ')[0] === 'Modulus:')\n\t\t\trsaParams['n'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'PublicExponent:')\n\t\t\trsaParams['e'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'PrivateExponent:')\n\t\t\trsaParams['d'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'Prime1:')\n\t\t\trsaParams['p'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'Prime2:')\n\t\t\trsaParams['q'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'Exponent1:')\n\t\t\trsaParams['dmodp'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'Exponent2:')\n\t\t\trsaParams['dmodq'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'Coefficient:')\n\t\t\trsaParams['iqmp'] = elementToBuf(element);\n\t});\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'rsa',\n\t\tparts: [\n\t\t\t{ name: 'e', data: utils.mpNormalize(rsaParams['e'])},\n\t\t\t{ name: 'n', data: utils.mpNormalize(rsaParams['n'])},\n\t\t\t{ name: 'd', data: utils.mpNormalize(rsaParams['d'])},\n\t\t\t{ name: 'p', data: utils.mpNormalize(rsaParams['p'])},\n\t\t\t{ name: 'q', data: utils.mpNormalize(rsaParams['q'])},\n\t\t\t{ name: 'dmodp',\n\t\t\t    data: utils.mpNormalize(rsaParams['dmodp'])},\n\t\t\t{ name: 'dmodq',\n\t\t\t    data: utils.mpNormalize(rsaParams['dmodq'])},\n\t\t\t{ name: 'iqmp',\n\t\t\t    data: utils.mpNormalize(rsaParams['iqmp'])}\n\t\t]\n\t};\n\treturn (new PrivateKey(key));\n}\n\nfunction readDNSSECPrivateKey(alg, elements) {\n\tif (supportedAlgosById[alg].match(/^RSA-/)) {\n\t\treturn (readDNSSECRSAPrivateKey(elements));\n\t}\n\tif (supportedAlgosById[alg] === 'ECDSA-P384-SHA384' ||\n\t    supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {\n\t\tvar d = Buffer.from(elements[0].split(' ')[1], 'base64');\n\t\tvar curve = 'nistp384';\n\t\tvar size = 384;\n\t\tif (supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {\n\t\t\tcurve = 'nistp256';\n\t\t\tsize = 256;\n\t\t}\n\t\t// DNSSEC generates the public-key on the fly (go calculate it)\n\t\tvar publicKey = utils.publicFromPrivateECDSA(curve, d);\n\t\tvar Q = publicKey.part['Q'].data;\n\t\tvar ecdsaKey = {\n\t\t\ttype: 'ecdsa',\n\t\t\tcurve: curve,\n\t\t\tsize: size,\n\t\t\tparts: [\n\t\t\t\t{name: 'curve', data: Buffer.from(curve) },\n\t\t\t\t{name: 'd', data: d },\n\t\t\t\t{name: 'Q', data: Q }\n\t\t\t]\n\t\t};\n\t\treturn (new PrivateKey(ecdsaKey));\n\t}\n\tthrow (new Error('Unsupported algorithm: ' + supportedAlgosById[alg]));\n}\n\nfunction dnssecTimestamp(date) {\n\tvar year = date.getFullYear() + ''; //stringify\n\tvar month = (date.getMonth() + 1);\n\tvar timestampStr = year + month + date.getUTCDate();\n\ttimestampStr += '' + date.getUTCHours() + date.getUTCMinutes();\n\ttimestampStr += date.getUTCSeconds();\n\treturn (timestampStr);\n}\n\nfunction rsaAlgFromOptions(opts) {\n\tif (!opts || !opts.hashAlgo || opts.hashAlgo === 'sha1')\n\t\treturn ('5 (RSASHA1)');\n\telse if (opts.hashAlgo === 'sha256')\n\t\treturn ('8 (RSASHA256)');\n\telse if (opts.hashAlgo === 'sha512')\n\t\treturn ('10 (RSASHA512)');\n\telse\n\t\tthrow (new Error('Unknown or unsupported hash: ' +\n\t\t    opts.hashAlgo));\n}\n\nfunction writeRSA(key, options) {\n\t// if we're missing parts, add them.\n\tif (!key.part.dmodp || !key.part.dmodq) {\n\t\tutils.addRSAMissing(key);\n\t}\n\n\tvar out = '';\n\tout += 'Private-key-format: v1.3\\n';\n\tout += 'Algorithm: ' + rsaAlgFromOptions(options) + '\\n';\n\tvar n = utils.mpDenormalize(key.part['n'].data);\n\tout += 'Modulus: ' + n.toString('base64') + '\\n';\n\tvar e = utils.mpDenormalize(key.part['e'].data);\n\tout += 'PublicExponent: ' + e.toString('base64') + '\\n';\n\tvar d = utils.mpDenormalize(key.part['d'].data);\n\tout += 'PrivateExponent: ' + d.toString('base64') + '\\n';\n\tvar p = utils.mpDenormalize(key.part['p'].data);\n\tout += 'Prime1: ' + p.toString('base64') + '\\n';\n\tvar q = utils.mpDenormalize(key.part['q'].data);\n\tout += 'Prime2: ' + q.toString('base64') + '\\n';\n\tvar dmodp = utils.mpDenormalize(key.part['dmodp'].data);\n\tout += 'Exponent1: ' + dmodp.toString('base64') + '\\n';\n\tvar dmodq = utils.mpDenormalize(key.part['dmodq'].data);\n\tout += 'Exponent2: ' + dmodq.toString('base64') + '\\n';\n\tvar iqmp = utils.mpDenormalize(key.part['iqmp'].data);\n\tout += 'Coefficient: ' + iqmp.toString('base64') + '\\n';\n\t// Assume that we're valid as-of now\n\tvar timestamp = new Date();\n\tout += 'Created: ' + dnssecTimestamp(timestamp) + '\\n';\n\tout += 'Publish: ' + dnssecTimestamp(timestamp) + '\\n';\n\tout += 'Activate: ' + dnssecTimestamp(timestamp) + '\\n';\n\treturn (Buffer.from(out, 'ascii'));\n}\n\nfunction writeECDSA(key, options) {\n\tvar out = '';\n\tout += 'Private-key-format: v1.3\\n';\n\n\tif (key.curve === 'nistp256') {\n\t\tout += 'Algorithm: 13 (ECDSAP256SHA256)\\n';\n\t} else if (key.curve === 'nistp384') {\n\t\tout += 'Algorithm: 14 (ECDSAP384SHA384)\\n';\n\t} else {\n\t\tthrow (new Error('Unsupported curve'));\n\t}\n\tvar base64Key = key.part['d'].data.toString('base64');\n\tout += 'PrivateKey: ' + base64Key + '\\n';\n\n\t// Assume that we're valid as-of now\n\tvar timestamp = new Date();\n\tout += 'Created: ' + dnssecTimestamp(timestamp) + '\\n';\n\tout += 'Publish: ' + dnssecTimestamp(timestamp) + '\\n';\n\tout += 'Activate: ' + dnssecTimestamp(timestamp) + '\\n';\n\n\treturn (Buffer.from(out, 'ascii'));\n}\n\nfunction write(key, options) {\n\tif (PrivateKey.isPrivateKey(key)) {\n\t\tif (key.type === 'rsa') {\n\t\t\treturn (writeRSA(key, options));\n\t\t} else if (key.type === 'ecdsa') {\n\t\t\treturn (writeECDSA(key, options));\n\t\t} else {\n\t\t\tthrow (new Error('Unsupported algorithm: ' + key.type));\n\t\t}\n\t} else if (Key.isKey(key)) {\n\t\t/*\n\t\t * RFC3110 requires a keyname, and a keytype, which we\n\t\t * don't really have a mechanism for specifying such\n\t\t * additional metadata.\n\t\t */\n\t\tthrow (new Error('Format \"dnssec\" only supports ' +\n\t\t    'writing private keys'));\n\t} else {\n\t\tthrow (new Error('key is not a Key or PrivateKey'));\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}