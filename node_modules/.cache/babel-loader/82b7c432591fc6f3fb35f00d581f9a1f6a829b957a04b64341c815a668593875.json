{"ast":null,"code":"module.exports = ForeverAgent;\nForeverAgent.SSL = ForeverAgentSSL;\nvar util = require('util'),\n  Agent = require('http').Agent,\n  net = require('net'),\n  tls = require('tls'),\n  AgentSSL = require('https').Agent;\nfunction getConnectionName(host, port) {\n  var name = '';\n  if (typeof host === 'string') {\n    name = host + ':' + port;\n  } else {\n    // For node.js v012.0 and iojs-v1.5.1, host is an object. And any existing localAddress is part of the connection name.\n    name = host.host + ':' + host.port + ':' + (host.localAddress ? host.localAddress + ':' : ':');\n  }\n  return name;\n}\nfunction ForeverAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.requests = {};\n  self.sockets = {};\n  self.freeSockets = {};\n  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets;\n  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets;\n  self.on('free', function (socket, host, port) {\n    var name = getConnectionName(host, port);\n    if (self.requests[name] && self.requests[name].length) {\n      self.requests[name].shift().onSocket(socket);\n    } else if (self.sockets[name].length < self.minSockets) {\n      if (!self.freeSockets[name]) self.freeSockets[name] = [];\n      self.freeSockets[name].push(socket);\n\n      // if an error happens while we don't use the socket anyway, meh, throw the socket away\n      var onIdleError = function () {\n        socket.destroy();\n      };\n      socket._onIdleError = onIdleError;\n      socket.on('error', onIdleError);\n    } else {\n      // If there are no pending requests just destroy the\n      // socket and it will get removed from the pool. This\n      // gets us out of timeout issues and allows us to\n      // default to Connection:keep-alive.\n      socket.destroy();\n    }\n  });\n}\nutil.inherits(ForeverAgent, Agent);\nForeverAgent.defaultMinSockets = 5;\nForeverAgent.prototype.createConnection = net.createConnection;\nForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest;\nForeverAgent.prototype.addRequest = function (req, host, port) {\n  var name = getConnectionName(host, port);\n  if (typeof host !== 'string') {\n    var options = host;\n    port = options.port;\n    host = options.host;\n  }\n  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {\n    var idleSocket = this.freeSockets[name].pop();\n    idleSocket.removeListener('error', idleSocket._onIdleError);\n    delete idleSocket._onIdleError;\n    req._reusedSocket = true;\n    req.onSocket(idleSocket);\n  } else {\n    this.addRequestNoreuse(req, host, port);\n  }\n};\nForeverAgent.prototype.removeSocket = function (s, name, host, port) {\n  if (this.sockets[name]) {\n    var index = this.sockets[name].indexOf(s);\n    if (index !== -1) {\n      this.sockets[name].splice(index, 1);\n    }\n  } else if (this.sockets[name] && this.sockets[name].length === 0) {\n    // don't leak\n    delete this.sockets[name];\n    delete this.requests[name];\n  }\n  if (this.freeSockets[name]) {\n    var index = this.freeSockets[name].indexOf(s);\n    if (index !== -1) {\n      this.freeSockets[name].splice(index, 1);\n      if (this.freeSockets[name].length === 0) {\n        delete this.freeSockets[name];\n      }\n    }\n  }\n  if (this.requests[name] && this.requests[name].length) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(name, host, port).emit('free');\n  }\n};\nfunction ForeverAgentSSL(options) {\n  ForeverAgent.call(this, options);\n}\nutil.inherits(ForeverAgentSSL, ForeverAgent);\nForeverAgentSSL.prototype.createConnection = createConnectionSSL;\nForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest;\nfunction createConnectionSSL(port, host, options) {\n  if (typeof port === 'object') {\n    options = port;\n  } else if (typeof host === 'object') {\n    options = host;\n  } else if (typeof options === 'object') {\n    options = options;\n  } else {\n    options = {};\n  }\n  if (typeof port === 'number') {\n    options.port = port;\n  }\n  if (typeof host === 'string') {\n    options.host = host;\n  }\n  return tls.connect(options);\n}","map":{"version":3,"names":["module","exports","ForeverAgent","SSL","ForeverAgentSSL","util","require","Agent","net","tls","AgentSSL","getConnectionName","host","port","name","localAddress","options","self","requests","sockets","freeSockets","maxSockets","defaultMaxSockets","minSockets","defaultMinSockets","on","socket","length","shift","onSocket","push","onIdleError","destroy","_onIdleError","inherits","prototype","createConnection","addRequestNoreuse","addRequest","req","useChunkedEncodingByDefault","idleSocket","pop","removeListener","_reusedSocket","removeSocket","s","index","indexOf","splice","createSocket","emit","call","createConnectionSSL","connect"],"sources":["/Users/mohitgupta/Downloads/orgs/Clone/inst/node_modules/forever-agent/index.js"],"sourcesContent":["module.exports = ForeverAgent\nForeverAgent.SSL = ForeverAgentSSL\n\nvar util = require('util')\n  , Agent = require('http').Agent\n  , net = require('net')\n  , tls = require('tls')\n  , AgentSSL = require('https').Agent\n  \nfunction getConnectionName(host, port) {  \n  var name = ''\n  if (typeof host === 'string') {\n    name = host + ':' + port\n  } else {\n    // For node.js v012.0 and iojs-v1.5.1, host is an object. And any existing localAddress is part of the connection name.\n    name = host.host + ':' + host.port + ':' + (host.localAddress ? (host.localAddress + ':') : ':')\n  }\n  return name\n}    \n\nfunction ForeverAgent(options) {\n  var self = this\n  self.options = options || {}\n  self.requests = {}\n  self.sockets = {}\n  self.freeSockets = {}\n  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets\n  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets\n  self.on('free', function(socket, host, port) {\n    var name = getConnectionName(host, port)\n\n    if (self.requests[name] && self.requests[name].length) {\n      self.requests[name].shift().onSocket(socket)\n    } else if (self.sockets[name].length < self.minSockets) {\n      if (!self.freeSockets[name]) self.freeSockets[name] = []\n      self.freeSockets[name].push(socket)\n      \n      // if an error happens while we don't use the socket anyway, meh, throw the socket away\n      var onIdleError = function() {\n        socket.destroy()\n      }\n      socket._onIdleError = onIdleError\n      socket.on('error', onIdleError)\n    } else {\n      // If there are no pending requests just destroy the\n      // socket and it will get removed from the pool. This\n      // gets us out of timeout issues and allows us to\n      // default to Connection:keep-alive.\n      socket.destroy()\n    }\n  })\n\n}\nutil.inherits(ForeverAgent, Agent)\n\nForeverAgent.defaultMinSockets = 5\n\n\nForeverAgent.prototype.createConnection = net.createConnection\nForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest\nForeverAgent.prototype.addRequest = function(req, host, port) {\n  var name = getConnectionName(host, port)\n  \n  if (typeof host !== 'string') {\n    var options = host\n    port = options.port\n    host = options.host\n  }\n\n  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {\n    var idleSocket = this.freeSockets[name].pop()\n    idleSocket.removeListener('error', idleSocket._onIdleError)\n    delete idleSocket._onIdleError\n    req._reusedSocket = true\n    req.onSocket(idleSocket)\n  } else {\n    this.addRequestNoreuse(req, host, port)\n  }\n}\n\nForeverAgent.prototype.removeSocket = function(s, name, host, port) {\n  if (this.sockets[name]) {\n    var index = this.sockets[name].indexOf(s)\n    if (index !== -1) {\n      this.sockets[name].splice(index, 1)\n    }\n  } else if (this.sockets[name] && this.sockets[name].length === 0) {\n    // don't leak\n    delete this.sockets[name]\n    delete this.requests[name]\n  }\n  \n  if (this.freeSockets[name]) {\n    var index = this.freeSockets[name].indexOf(s)\n    if (index !== -1) {\n      this.freeSockets[name].splice(index, 1)\n      if (this.freeSockets[name].length === 0) {\n        delete this.freeSockets[name]\n      }\n    }\n  }\n\n  if (this.requests[name] && this.requests[name].length) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(name, host, port).emit('free')\n  }\n}\n\nfunction ForeverAgentSSL (options) {\n  ForeverAgent.call(this, options)\n}\nutil.inherits(ForeverAgentSSL, ForeverAgent)\n\nForeverAgentSSL.prototype.createConnection = createConnectionSSL\nForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest\n\nfunction createConnectionSSL (port, host, options) {\n  if (typeof port === 'object') {\n    options = port;\n  } else if (typeof host === 'object') {\n    options = host;\n  } else if (typeof options === 'object') {\n    options = options;\n  } else {\n    options = {};\n  }\n\n  if (typeof port === 'number') {\n    options.port = port;\n  }\n\n  if (typeof host === 'string') {\n    options.host = host;\n  }\n\n  return tls.connect(options);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}