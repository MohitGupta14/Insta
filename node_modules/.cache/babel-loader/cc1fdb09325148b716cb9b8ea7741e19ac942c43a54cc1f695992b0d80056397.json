{"ast":null,"code":"// Copyright 2018 Joyent, Inc.\n\nmodule.exports = {\n  read: read,\n  write: write\n};\nvar assert = require('assert-plus');\nvar asn1 = require('asn1');\nvar crypto = require('crypto');\nvar Buffer = require('safer-buffer').Buffer;\nvar algs = require('../algs');\nvar utils = require('../utils');\nvar Key = require('../key');\nvar PrivateKey = require('../private-key');\nvar pkcs1 = require('./pkcs1');\nvar pkcs8 = require('./pkcs8');\nvar sshpriv = require('./ssh-private');\nvar rfc4253 = require('./rfc4253');\nvar errors = require('../errors');\nvar OID_PBES2 = '1.2.840.113549.1.5.13';\nvar OID_PBKDF2 = '1.2.840.113549.1.5.12';\nvar OID_TO_CIPHER = {\n  '1.2.840.113549.3.7': '3des-cbc',\n  '2.16.840.1.101.3.4.1.2': 'aes128-cbc',\n  '2.16.840.1.101.3.4.1.42': 'aes256-cbc'\n};\nvar CIPHER_TO_OID = {};\nObject.keys(OID_TO_CIPHER).forEach(function (k) {\n  CIPHER_TO_OID[OID_TO_CIPHER[k]] = k;\n});\nvar OID_TO_HASH = {\n  '1.2.840.113549.2.7': 'sha1',\n  '1.2.840.113549.2.9': 'sha256',\n  '1.2.840.113549.2.11': 'sha512'\n};\nvar HASH_TO_OID = {};\nObject.keys(OID_TO_HASH).forEach(function (k) {\n  HASH_TO_OID[OID_TO_HASH[k]] = k;\n});\n\n/*\n * For reading we support both PKCS#1 and PKCS#8. If we find a private key,\n * we just take the public component of it and use that.\n */\nfunction read(buf, options, forceType) {\n  var input = buf;\n  if (typeof buf !== 'string') {\n    assert.buffer(buf, 'buf');\n    buf = buf.toString('ascii');\n  }\n  var lines = buf.trim().split(/[\\r\\n]+/g);\n  var m;\n  var si = -1;\n  while (!m && si < lines.length) {\n    m = lines[++si].match( /*JSSTYLED*/\n    /[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);\n  }\n  assert.ok(m, 'invalid PEM header');\n  var m2;\n  var ei = lines.length;\n  while (!m2 && ei > 0) {\n    m2 = lines[--ei].match( /*JSSTYLED*/\n    /[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);\n  }\n  assert.ok(m2, 'invalid PEM footer');\n\n  /* Begin and end banners must match key type */\n  assert.equal(m[2], m2[2]);\n  var type = m[2].toLowerCase();\n  var alg;\n  if (m[1]) {\n    /* They also must match algorithms, if given */\n    assert.equal(m[1], m2[1], 'PEM header and footer mismatch');\n    alg = m[1].trim();\n  }\n  lines = lines.slice(si, ei + 1);\n  var headers = {};\n  while (true) {\n    lines = lines.slice(1);\n    m = lines[0].match( /*JSSTYLED*/\n    /^([A-Za-z0-9-]+): (.+)$/);\n    if (!m) break;\n    headers[m[1].toLowerCase()] = m[2];\n  }\n\n  /* Chop off the first and last lines */\n  lines = lines.slice(0, -1).join('');\n  buf = Buffer.from(lines, 'base64');\n  var cipher, key, iv;\n  if (headers['proc-type']) {\n    var parts = headers['proc-type'].split(',');\n    if (parts[0] === '4' && parts[1] === 'ENCRYPTED') {\n      if (typeof options.passphrase === 'string') {\n        options.passphrase = Buffer.from(options.passphrase, 'utf-8');\n      }\n      if (!Buffer.isBuffer(options.passphrase)) {\n        throw new errors.KeyEncryptedError(options.filename, 'PEM');\n      } else {\n        parts = headers['dek-info'].split(',');\n        assert.ok(parts.length === 2);\n        cipher = parts[0].toLowerCase();\n        iv = Buffer.from(parts[1], 'hex');\n        key = utils.opensslKeyDeriv(cipher, iv, options.passphrase, 1).key;\n      }\n    }\n  }\n  if (alg && alg.toLowerCase() === 'encrypted') {\n    var eder = new asn1.BerReader(buf);\n    var pbesEnd;\n    eder.readSequence();\n    eder.readSequence();\n    pbesEnd = eder.offset + eder.length;\n    var method = eder.readOID();\n    if (method !== OID_PBES2) {\n      throw new Error('Unsupported PEM/PKCS8 encryption ' + 'scheme: ' + method);\n    }\n    eder.readSequence(); /* PBES2-params */\n\n    eder.readSequence(); /* keyDerivationFunc */\n    var kdfEnd = eder.offset + eder.length;\n    var kdfOid = eder.readOID();\n    if (kdfOid !== OID_PBKDF2) throw new Error('Unsupported PBES2 KDF: ' + kdfOid);\n    eder.readSequence();\n    var salt = eder.readString(asn1.Ber.OctetString, true);\n    var iterations = eder.readInt();\n    var hashAlg = 'sha1';\n    if (eder.offset < kdfEnd) {\n      eder.readSequence();\n      var hashAlgOid = eder.readOID();\n      hashAlg = OID_TO_HASH[hashAlgOid];\n      if (hashAlg === undefined) {\n        throw new Error('Unsupported PBKDF2 hash: ' + hashAlgOid);\n      }\n    }\n    eder._offset = kdfEnd;\n    eder.readSequence(); /* encryptionScheme */\n    var cipherOid = eder.readOID();\n    cipher = OID_TO_CIPHER[cipherOid];\n    if (cipher === undefined) {\n      throw new Error('Unsupported PBES2 cipher: ' + cipherOid);\n    }\n    iv = eder.readString(asn1.Ber.OctetString, true);\n    eder._offset = pbesEnd;\n    buf = eder.readString(asn1.Ber.OctetString, true);\n    if (typeof options.passphrase === 'string') {\n      options.passphrase = Buffer.from(options.passphrase, 'utf-8');\n    }\n    if (!Buffer.isBuffer(options.passphrase)) {\n      throw new errors.KeyEncryptedError(options.filename, 'PEM');\n    }\n    var cinfo = utils.opensshCipherInfo(cipher);\n    cipher = cinfo.opensslName;\n    key = utils.pbkdf2(hashAlg, salt, iterations, cinfo.keySize, options.passphrase);\n    alg = undefined;\n  }\n  if (cipher && key && iv) {\n    var cipherStream = crypto.createDecipheriv(cipher, key, iv);\n    var chunk,\n      chunks = [];\n    cipherStream.once('error', function (e) {\n      if (e.toString().indexOf('bad decrypt') !== -1) {\n        throw new Error('Incorrect passphrase ' + 'supplied, could not decrypt key');\n      }\n      throw e;\n    });\n    cipherStream.write(buf);\n    cipherStream.end();\n    while ((chunk = cipherStream.read()) !== null) chunks.push(chunk);\n    buf = Buffer.concat(chunks);\n  }\n\n  /* The new OpenSSH internal format abuses PEM headers */\n  if (alg && alg.toLowerCase() === 'openssh') return sshpriv.readSSHPrivate(type, buf, options);\n  if (alg && alg.toLowerCase() === 'ssh2') return rfc4253.readType(type, buf, options);\n  var der = new asn1.BerReader(buf);\n  der.originalInput = input;\n\n  /*\n   * All of the PEM file types start with a sequence tag, so chop it\n   * off here\n   */\n  der.readSequence();\n\n  /* PKCS#1 type keys name an algorithm in the banner explicitly */\n  if (alg) {\n    if (forceType) assert.strictEqual(forceType, 'pkcs1');\n    return pkcs1.readPkcs1(alg, type, der);\n  } else {\n    if (forceType) assert.strictEqual(forceType, 'pkcs8');\n    return pkcs8.readPkcs8(alg, type, der);\n  }\n}\nfunction write(key, options, type) {\n  assert.object(key);\n  var alg = {\n    'ecdsa': 'EC',\n    'rsa': 'RSA',\n    'dsa': 'DSA',\n    'ed25519': 'EdDSA'\n  }[key.type];\n  var header;\n  var der = new asn1.BerWriter();\n  if (PrivateKey.isPrivateKey(key)) {\n    if (type && type === 'pkcs8') {\n      header = 'PRIVATE KEY';\n      pkcs8.writePkcs8(der, key);\n    } else {\n      if (type) assert.strictEqual(type, 'pkcs1');\n      header = alg + ' PRIVATE KEY';\n      pkcs1.writePkcs1(der, key);\n    }\n  } else if (Key.isKey(key)) {\n    if (type && type === 'pkcs1') {\n      header = alg + ' PUBLIC KEY';\n      pkcs1.writePkcs1(der, key);\n    } else {\n      if (type) assert.strictEqual(type, 'pkcs8');\n      header = 'PUBLIC KEY';\n      pkcs8.writePkcs8(der, key);\n    }\n  } else {\n    throw new Error('key is not a Key or PrivateKey');\n  }\n  var tmp = der.buffer.toString('base64');\n  var len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10;\n  var buf = Buffer.alloc(len);\n  var o = 0;\n  o += buf.write('-----BEGIN ' + header + '-----\\n', o);\n  for (var i = 0; i < tmp.length;) {\n    var limit = i + 64;\n    if (limit > tmp.length) limit = tmp.length;\n    o += buf.write(tmp.slice(i, limit), o);\n    buf[o++] = 10;\n    i = limit;\n  }\n  o += buf.write('-----END ' + header + '-----\\n', o);\n  return buf.slice(0, o);\n}","map":{"version":3,"names":["module","exports","read","write","assert","require","asn1","crypto","Buffer","algs","utils","Key","PrivateKey","pkcs1","pkcs8","sshpriv","rfc4253","errors","OID_PBES2","OID_PBKDF2","OID_TO_CIPHER","CIPHER_TO_OID","Object","keys","forEach","k","OID_TO_HASH","HASH_TO_OID","buf","options","forceType","input","buffer","toString","lines","trim","split","m","si","length","match","ok","m2","ei","equal","type","toLowerCase","alg","slice","headers","join","from","cipher","key","iv","parts","passphrase","isBuffer","KeyEncryptedError","filename","opensslKeyDeriv","eder","BerReader","pbesEnd","readSequence","offset","method","readOID","Error","kdfEnd","kdfOid","salt","readString","Ber","OctetString","iterations","readInt","hashAlg","hashAlgOid","undefined","_offset","cipherOid","cinfo","opensshCipherInfo","opensslName","pbkdf2","keySize","cipherStream","createDecipheriv","chunk","chunks","once","e","indexOf","end","push","concat","readSSHPrivate","readType","der","originalInput","strictEqual","readPkcs1","readPkcs8","object","header","BerWriter","isPrivateKey","writePkcs8","writePkcs1","isKey","tmp","len","alloc","o","i","limit"],"sources":["/Users/mohitgupta/Downloads/orgs/Clone/inst/node_modules/sshpk/lib/formats/pem.js"],"sourcesContent":["// Copyright 2018 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\twrite: write\n};\n\nvar assert = require('assert-plus');\nvar asn1 = require('asn1');\nvar crypto = require('crypto');\nvar Buffer = require('safer-buffer').Buffer;\nvar algs = require('../algs');\nvar utils = require('../utils');\nvar Key = require('../key');\nvar PrivateKey = require('../private-key');\n\nvar pkcs1 = require('./pkcs1');\nvar pkcs8 = require('./pkcs8');\nvar sshpriv = require('./ssh-private');\nvar rfc4253 = require('./rfc4253');\n\nvar errors = require('../errors');\n\nvar OID_PBES2 = '1.2.840.113549.1.5.13';\nvar OID_PBKDF2 = '1.2.840.113549.1.5.12';\n\nvar OID_TO_CIPHER = {\n\t'1.2.840.113549.3.7': '3des-cbc',\n\t'2.16.840.1.101.3.4.1.2': 'aes128-cbc',\n\t'2.16.840.1.101.3.4.1.42': 'aes256-cbc'\n};\nvar CIPHER_TO_OID = {};\nObject.keys(OID_TO_CIPHER).forEach(function (k) {\n\tCIPHER_TO_OID[OID_TO_CIPHER[k]] = k;\n});\n\nvar OID_TO_HASH = {\n\t'1.2.840.113549.2.7': 'sha1',\n\t'1.2.840.113549.2.9': 'sha256',\n\t'1.2.840.113549.2.11': 'sha512'\n};\nvar HASH_TO_OID = {};\nObject.keys(OID_TO_HASH).forEach(function (k) {\n\tHASH_TO_OID[OID_TO_HASH[k]] = k;\n});\n\n/*\n * For reading we support both PKCS#1 and PKCS#8. If we find a private key,\n * we just take the public component of it and use that.\n */\nfunction read(buf, options, forceType) {\n\tvar input = buf;\n\tif (typeof (buf) !== 'string') {\n\t\tassert.buffer(buf, 'buf');\n\t\tbuf = buf.toString('ascii');\n\t}\n\n\tvar lines = buf.trim().split(/[\\r\\n]+/g);\n\n\tvar m;\n\tvar si = -1;\n\twhile (!m && si < lines.length) {\n\t\tm = lines[++si].match(/*JSSTYLED*/\n\t\t    /[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);\n\t}\n\tassert.ok(m, 'invalid PEM header');\n\n\tvar m2;\n\tvar ei = lines.length;\n\twhile (!m2 && ei > 0) {\n\t\tm2 = lines[--ei].match(/*JSSTYLED*/\n\t\t    /[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);\n\t}\n\tassert.ok(m2, 'invalid PEM footer');\n\n\t/* Begin and end banners must match key type */\n\tassert.equal(m[2], m2[2]);\n\tvar type = m[2].toLowerCase();\n\n\tvar alg;\n\tif (m[1]) {\n\t\t/* They also must match algorithms, if given */\n\t\tassert.equal(m[1], m2[1], 'PEM header and footer mismatch');\n\t\talg = m[1].trim();\n\t}\n\n\tlines = lines.slice(si, ei + 1);\n\n\tvar headers = {};\n\twhile (true) {\n\t\tlines = lines.slice(1);\n\t\tm = lines[0].match(/*JSSTYLED*/\n\t\t    /^([A-Za-z0-9-]+): (.+)$/);\n\t\tif (!m)\n\t\t\tbreak;\n\t\theaders[m[1].toLowerCase()] = m[2];\n\t}\n\n\t/* Chop off the first and last lines */\n\tlines = lines.slice(0, -1).join('');\n\tbuf = Buffer.from(lines, 'base64');\n\n\tvar cipher, key, iv;\n\tif (headers['proc-type']) {\n\t\tvar parts = headers['proc-type'].split(',');\n\t\tif (parts[0] === '4' && parts[1] === 'ENCRYPTED') {\n\t\t\tif (typeof (options.passphrase) === 'string') {\n\t\t\t\toptions.passphrase = Buffer.from(\n\t\t\t\t    options.passphrase, 'utf-8');\n\t\t\t}\n\t\t\tif (!Buffer.isBuffer(options.passphrase)) {\n\t\t\t\tthrow (new errors.KeyEncryptedError(\n\t\t\t\t    options.filename, 'PEM'));\n\t\t\t} else {\n\t\t\t\tparts = headers['dek-info'].split(',');\n\t\t\t\tassert.ok(parts.length === 2);\n\t\t\t\tcipher = parts[0].toLowerCase();\n\t\t\t\tiv = Buffer.from(parts[1], 'hex');\n\t\t\t\tkey = utils.opensslKeyDeriv(cipher, iv,\n\t\t\t\t    options.passphrase, 1).key;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (alg && alg.toLowerCase() === 'encrypted') {\n\t\tvar eder = new asn1.BerReader(buf);\n\t\tvar pbesEnd;\n\t\teder.readSequence();\n\n\t\teder.readSequence();\n\t\tpbesEnd = eder.offset + eder.length;\n\n\t\tvar method = eder.readOID();\n\t\tif (method !== OID_PBES2) {\n\t\t\tthrow (new Error('Unsupported PEM/PKCS8 encryption ' +\n\t\t\t    'scheme: ' + method));\n\t\t}\n\n\t\teder.readSequence();\t/* PBES2-params */\n\n\t\teder.readSequence();\t/* keyDerivationFunc */\n\t\tvar kdfEnd = eder.offset + eder.length;\n\t\tvar kdfOid = eder.readOID();\n\t\tif (kdfOid !== OID_PBKDF2)\n\t\t\tthrow (new Error('Unsupported PBES2 KDF: ' + kdfOid));\n\t\teder.readSequence();\n\t\tvar salt = eder.readString(asn1.Ber.OctetString, true);\n\t\tvar iterations = eder.readInt();\n\t\tvar hashAlg = 'sha1';\n\t\tif (eder.offset < kdfEnd) {\n\t\t\teder.readSequence();\n\t\t\tvar hashAlgOid = eder.readOID();\n\t\t\thashAlg = OID_TO_HASH[hashAlgOid];\n\t\t\tif (hashAlg === undefined) {\n\t\t\t\tthrow (new Error('Unsupported PBKDF2 hash: ' +\n\t\t\t\t    hashAlgOid));\n\t\t\t}\n\t\t}\n\t\teder._offset = kdfEnd;\n\n\t\teder.readSequence();\t/* encryptionScheme */\n\t\tvar cipherOid = eder.readOID();\n\t\tcipher = OID_TO_CIPHER[cipherOid];\n\t\tif (cipher === undefined) {\n\t\t\tthrow (new Error('Unsupported PBES2 cipher: ' +\n\t\t\t    cipherOid));\n\t\t}\n\t\tiv = eder.readString(asn1.Ber.OctetString, true);\n\n\t\teder._offset = pbesEnd;\n\t\tbuf = eder.readString(asn1.Ber.OctetString, true);\n\n\t\tif (typeof (options.passphrase) === 'string') {\n\t\t\toptions.passphrase = Buffer.from(\n\t\t\t    options.passphrase, 'utf-8');\n\t\t}\n\t\tif (!Buffer.isBuffer(options.passphrase)) {\n\t\t\tthrow (new errors.KeyEncryptedError(\n\t\t\t    options.filename, 'PEM'));\n\t\t}\n\n\t\tvar cinfo = utils.opensshCipherInfo(cipher);\n\n\t\tcipher = cinfo.opensslName;\n\t\tkey = utils.pbkdf2(hashAlg, salt, iterations, cinfo.keySize,\n\t\t    options.passphrase);\n\t\talg = undefined;\n\t}\n\n\tif (cipher && key && iv) {\n\t\tvar cipherStream = crypto.createDecipheriv(cipher, key, iv);\n\t\tvar chunk, chunks = [];\n\t\tcipherStream.once('error', function (e) {\n\t\t\tif (e.toString().indexOf('bad decrypt') !== -1) {\n\t\t\t\tthrow (new Error('Incorrect passphrase ' +\n\t\t\t\t    'supplied, could not decrypt key'));\n\t\t\t}\n\t\t\tthrow (e);\n\t\t});\n\t\tcipherStream.write(buf);\n\t\tcipherStream.end();\n\t\twhile ((chunk = cipherStream.read()) !== null)\n\t\t\tchunks.push(chunk);\n\t\tbuf = Buffer.concat(chunks);\n\t}\n\n\t/* The new OpenSSH internal format abuses PEM headers */\n\tif (alg && alg.toLowerCase() === 'openssh')\n\t\treturn (sshpriv.readSSHPrivate(type, buf, options));\n\tif (alg && alg.toLowerCase() === 'ssh2')\n\t\treturn (rfc4253.readType(type, buf, options));\n\n\tvar der = new asn1.BerReader(buf);\n\tder.originalInput = input;\n\n\t/*\n\t * All of the PEM file types start with a sequence tag, so chop it\n\t * off here\n\t */\n\tder.readSequence();\n\n\t/* PKCS#1 type keys name an algorithm in the banner explicitly */\n\tif (alg) {\n\t\tif (forceType)\n\t\t\tassert.strictEqual(forceType, 'pkcs1');\n\t\treturn (pkcs1.readPkcs1(alg, type, der));\n\t} else {\n\t\tif (forceType)\n\t\t\tassert.strictEqual(forceType, 'pkcs8');\n\t\treturn (pkcs8.readPkcs8(alg, type, der));\n\t}\n}\n\nfunction write(key, options, type) {\n\tassert.object(key);\n\n\tvar alg = {\n\t    'ecdsa': 'EC',\n\t    'rsa': 'RSA',\n\t    'dsa': 'DSA',\n\t    'ed25519': 'EdDSA'\n\t}[key.type];\n\tvar header;\n\n\tvar der = new asn1.BerWriter();\n\n\tif (PrivateKey.isPrivateKey(key)) {\n\t\tif (type && type === 'pkcs8') {\n\t\t\theader = 'PRIVATE KEY';\n\t\t\tpkcs8.writePkcs8(der, key);\n\t\t} else {\n\t\t\tif (type)\n\t\t\t\tassert.strictEqual(type, 'pkcs1');\n\t\t\theader = alg + ' PRIVATE KEY';\n\t\t\tpkcs1.writePkcs1(der, key);\n\t\t}\n\n\t} else if (Key.isKey(key)) {\n\t\tif (type && type === 'pkcs1') {\n\t\t\theader = alg + ' PUBLIC KEY';\n\t\t\tpkcs1.writePkcs1(der, key);\n\t\t} else {\n\t\t\tif (type)\n\t\t\t\tassert.strictEqual(type, 'pkcs8');\n\t\t\theader = 'PUBLIC KEY';\n\t\t\tpkcs8.writePkcs8(der, key);\n\t\t}\n\n\t} else {\n\t\tthrow (new Error('key is not a Key or PrivateKey'));\n\t}\n\n\tvar tmp = der.buffer.toString('base64');\n\tvar len = tmp.length + (tmp.length / 64) +\n\t    18 + 16 + header.length*2 + 10;\n\tvar buf = Buffer.alloc(len);\n\tvar o = 0;\n\to += buf.write('-----BEGIN ' + header + '-----\\n', o);\n\tfor (var i = 0; i < tmp.length; ) {\n\t\tvar limit = i + 64;\n\t\tif (limit > tmp.length)\n\t\t\tlimit = tmp.length;\n\t\to += buf.write(tmp.slice(i, limit), o);\n\t\tbuf[o++] = 10;\n\t\ti = limit;\n\t}\n\to += buf.write('-----END ' + header + '-----\\n', o);\n\n\treturn (buf.slice(0, o));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}